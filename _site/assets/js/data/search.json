[
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 2주차 회고",
    "url": "/posts/week2/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-26 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋...",
    "content": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋았던 점 (좋았거나 내가 잘했던 점)- 5층 도서관?에 원하는 책이 생겨서 바로 빌릴 수 있었다 ㅎ- 매니저님들이 수업과 공부에 집중할 수 있도록 환경을 조성해주는것에이 글을 통해서 큰 감사의 인사를 드립니다.3. 아쉬웠던 점- 시간이 지나감에 따라 다른 기수들도 팀프로젝트를 하러 윗층까지 올라오는데,모임을 하는 장소가 적은거같은 느낌이 들고또한 대형tv가 있는 자리는 정해졌기에 자리경쟁이 치열해질 것으로 보인다.- 강의때 내용을 블로그에 바로 적을려고 했지만, 아직까지 마크다운 사용법이 익숙하지않아서 바로 실행에 옮기지 못했다. 4. 개선할 점- 자바와 웹개발이 처음이다보니 모르는것이 너무나도 많은데목표를 정해 하나씩 달성해나갈 수 있도록 하자 !!!5. 다음주 계획- 마크다운에 대한 블로그 글 업로드!!!"
  },
  
  {
    "title": "자바 Thread_2",
    "url": "/posts/Java-Thread2/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-23 23:09:22 +0900",
    





    
    "snippet": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이...",
    "content": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이션 전체를 중단하기 위해서임 !(최소 하나의 스레드만 실행되고 있어도 프로세스는 종료되지않음)Thread.interrupt()-&gt; 각 스레드는 인터럭트 메서드를 가지고 있음  우리가 인터럽트하려는 스레드가 인터럽트 당했을 때 익셉션을 발생시키는 경우 !  이터럽트하려는 스레드가 신호를 명시적으로 처리하기 위해 !    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.start();        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }    }    private BigInteger pow(BigInteger base, BigInteger power) {        BigInteger result = BigInteger.ONE;        for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {            if(Thread.currentThread().isInterrupted()) {                System.out.println(\"interrupted\");                return BigInteger.ZERO;            }            result = result.multiply(base);        }        return result;    }}Thread Daemon  메인 스레드가 종료되어도 애플리케이션 종료를 막지 않음.  주로 백그라운드 작업 (텍스트앱에서 시간마다 자동저장하는 기능)  작업 스레드에서 실행되는 코드를 제어할 수 없는 경우, Daemon쓰레드가 앱 종료를 방해하는 일은 없어야함.    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.setDaemon(true);        thread.start();        Thread.sleep(100);        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }        private BigInteger pow(BigInteger base, BigInteger power) {            BigInteger result = BigInteger.ONE;            for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {                if(Thread.currentThread().isInterrupted()) {                    System.out.println(\"interrupted\");                    return BigInteger.ZERO;                }                result = result.multiply(base);            }            return result;        }    }Thread join  스레드는 각각 독립적이고 실행순서를 우리가 통제할 수 없다.  "
  },
  
  {
    "title": "자바 Thread_1",
    "url": "/posts/Java-Thread/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-20 23:09:22 +0900",
    





    
    "snippet": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/...",
    "content": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/br&gt; &lt;/br&gt;                  컨텍스트 스위치                            동시에 많은 스레드를 다룰 때는 효율성이 떨어지기에 이 개념이 아주 중요함 !      사람으로 생각하면 생각을 가다듬고, 집중력을 회복하는 시간 ! (회사에서 많은 업무를 동시에 못하는것처럼!!)      CPU에서 실행되는 각 스레드는 CPU 안에 레지스터, 캐시, 메모리 내의 커널 리소스 일정 부분을 차지하게됨.다른 쓰레드로 전환할 때는 기존의 모든 데이터를 저장하고, 다른 쓰레드의 리소스를 CPU와 메모리에 복원해야함.            너무 많은 스레드를 사용시 ‘스래싱’이 발행    같은 프로세스에 속한 두 스레드 간의 컨텍스트 스위치(효율) » 다른 프로세스의 두 스레드간의 스위치(비효율)      그럼 언제 컨텍스트 스위치를 할 지 결정하는가??    쓰레드 스케줄          들어온 순서대로 작업을 처리할지?      짧은 시간인것부터 먼저 처리할지?        쓰레드 vs 프로세스          멀티 스레드와 멀티 프로세스.      스레드는 많은 리소스를 공유하니 같은 프로세스 안에서 스레드를 사용하는 것이 좋음.      보안,안정성 -&gt; 멀티 스레드는 스레드 하나에 프로세스가 다운될 가능성도 있음.      자바 스레드의 기능과 디버깅 방법        // 스레드 생성        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                System.out.println(\"now thread: \" + Thread.currentThread().getName());                System.out.println(\"current thread: \" + Thread.currentThread().getPriority());                /* 에러 반환 */                throw new RuntimeException(\"Exception\");            }        });        // 스레드에 문제를 생겼을때 해당 헨들러가 작동해서 에러를 반환        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                System.out.println(\"error happy\");            }        });&lt;/br&gt;자바 스레드 상속 예제public static final int MAX_PASSWORD = 9999;    public static void main(String[] args) throws InterruptedException {        Random random = new Random();        Vault vault = new Vault(random.nextInt(MAX_PASSWORD));        // 모든 클래스가 Thread클래스를 상속받았기에 제네릭으로 사용 가능함.        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();        threads.add(new AscendingHackerThread(vault));        threads.add(new DescendingHackerThread(vault));        threads.add(new PoliceThread());        // 쓰레드 담긴 개수만큼 반복해서 실행        for (Thread thread : threads) {            thread.start();        }    }    // 해당 방법처럼 클래스에 쓰레드를 상속받아서 쓰레드클래스로 사용 가능    private static class NewThread extends Thread {        @Override        public void run(){            System.out.println(\"Hello\" + this.getName());        }    }    private static class Vault {        private int passward;        public Vault(int passward) {            this.passward = passward;        }        public boolean isCorrentPassword(int guess) {            try {                Thread.sleep(5);            } catch (Exception e){            }            return this.passward == guess;        }    }    // 쓰레드를 상속받은 클래스를 추상클래스로 만들어 활용    private static abstract class HackerThread extends Thread {        protected Vault vault;        public HackerThread(Vault vault) {            this.vault = vault;            this.setName(this.getClass().getSimpleName());            this.setPriority(Thread.MAX_PRIORITY);        }        @Override        public void start() {            System.out.println(\"string thread: \" + this.getName());            super.start();        }    }    private static class AscendingHackerThread extends HackerThread {        public AscendingHackerThread(Vault vault) {            super(vault);        }        @Override        public void run() {            for (int i = 0; i &lt; MAX_PASSWORD; i++) {                if(vault.isCorrentPassword(i)){                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class DescendingHackerThread extends HackerThread {        public DescendingHackerThread(Vault vault){            super(vault);        }        @Override        public void run() {            for (int i = MAX_PASSWORD; i &gt;= 0; i--) {                if (vault.isCorrentPassword(i)) {                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class PoliceThread extends Thread {        @Override        public void run() {            for (int i = 10; i &gt; 0; i--) {                try {                    Thread.sleep(1000);                }catch (Exception e) {                }                System.out.println(i);            }            System.out.println(\"Over Hacker\");            System.exit(0);        }    }핵심 !!!!      애플리케이션에서 여러 개의 스레드를 사용하는 이유는 무엇일까요?  =&gt; 여러 개의 스레드를 사용하면 동시에 여러 개의 관련 작업을 실행할 수 있어서, 애플리케이션의 반응성을 향상시킬 수 있기 때문입니다. 또한 여러 개의 작업을 동시에 실행하여 더 뛰어난 성능을 달성할 수도 있습니다.        하나의 프로세스에 속한 스레드가 공유하는 것은?  =&gt; 힙, 코드, 프로세스의 열린 파일, 프로세스의 메타 데이터        OS는 어떤 방식으로 스케줄링할 스레드를 설계하는가?  =&gt; 각 스레드에 대한 동적 우선 순위를 유지해 인터랙티브 스레드를 우선시하고 시스템의 특정 스레드가 기아 상태가 되는 것을 방지하는것이 모든 OS의 목표 (스케줄링 스레드에 대한 알고리즘은 OS마다 다름)  "
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 1주차 회고",
    "url": "/posts/week1/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-19 12:00:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장...",
    "content": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장 경험이 있었다는 점.  국비는 강사의 역량이 절반이상이라도 들었는데, 적어도 인터넷에서 본 이상한 강사님이 아니라서 좋았다.  - 커리큘럼을 봤을때 생각보다 탄탄했다. (CI/CD까지 하는 곳은 잘 못본거같은데, 거기다가 Action!!)  - 생각보다 건물 안이 깨끗했고 원두커피를 아침, 점심, 저녁마다 먹을 수 있었다 !- 매니저님들이 생각 이상으로 신경을 잘 써주시고, 최대한 도와주시려고 함. 3. 아쉬웠던 점- 일단 화장실이 너무 작았다. 갈때마다 기다리는게 쉽지 않다.  - 수업을 듣는 교육실이 생각보다 작았고, 듀얼모니터 지원X (너무 좋은 환경의 이야기만 들은것일 순 있음)- 커리큘럼의 내용이 탄탄한만큼 시간안에 끝낼 수 있는지 강사님이 먼저 걱정된다;;;  - 내용을 제로베이스에서 시작 + 짧은시간 + 많은 내용을 하다보니 토익700점반처럼 내용을 공식처럼 외우는 느낌이였음. 4. 개선할 점- 앞으로는 강사님 수업내용을 블로그에 바로 정리해서 올릴 수 있도록 하기 !5. 다음주 계획- 블로그를 빠르게 적기위해, 마크다운을 익숙해지도록 하기- 자바 공부 및 정리."
  },
  
  {
    "title": "첫 블로그 글, 소개",
    "url": "/posts/intro/",
    "categories": "일상, 소개",
    "tags": "introduce",
    "date": "2023-11-17 23:09:22 +0900",
    





    
    "snippet": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 ...",
    "content": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 대해 필요한 부분들 정리    추후 꾸준하게 해당글을 수정하도록 약속함."
  }
  
]

