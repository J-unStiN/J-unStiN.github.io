[
  
  {
    "title": "네트워크1 - google.com",
    "url": "/posts/network01/",
    "categories": "개발, 네트워크",
    "tags": "network",
    "date": "2023-12-19 19:37:00 +0900",
    





    
    "snippet": "웹브라우저에 www.google.com 을 치면 무슨 일이 일어나는가?구글 서버의 80포트로 htttp req메시지를 보내는것.해당 요청을 인터넷을 통해 구글에 요청하기위해 패킷을 만들어야함.ㅁ응용계층: http, dns, smtp 등 =&gt; HTTP 요청ㅁ전송계층TCP로 연결  SP 시작포트번호: 내컴퓨터 포트번호  DP 목적지포트번호: www....",
    "content": "웹브라우저에 www.google.com 을 치면 무슨 일이 일어나는가?구글 서버의 80포트로 htttp req메시지를 보내는것.해당 요청을 인터넷을 통해 구글에 요청하기위해 패킷을 만들어야함.ㅁ응용계층: http, dns, smtp 등 =&gt; HTTP 요청ㅁ전송계층TCP로 연결  SP 시작포트번호: 내컴퓨터 포트번호  DP 목적지포트번호: www.google.com 은 80포트로 알고있음.ㅁ인터넷계층  SA 시작아이피주소: 내 시작주소는 당연히 알고있음  DA 목적지아이피주소: 도메인정보만 알고있음. -&gt;  DNS프로토콜을 통해 알아낼수있음.  브라우저는 OS에게 www.google.com에 대한 IP주소를 알고 싶다고 요청함. -&gt; OS에서 DNS서버로 요청을 보내게 된다.  DNS서버 주소는 이미 OS에 구현이 되어있음.  DNS도 도메민이 담긴 쿼리를 보내고 도메인서버가 IP주소를 res받음.  DNS는 UDP 통신을 사용함.ㅁ네트워크액세스계층  MAC주소를 알아야함.  물리적으로 연결된 우리집 공유기의 MAC주소가 필요함  네트워크 연결이 가능한 통로를 게이트웨이라함. (netstat 확인가능)  ARP 를 통해 IP 주소를 MAC주소로 변환ㅁ데이터를 전송하기 전에 연결을 위한 3way-hand-shaking이 필요함.ㅁ연결해제는 4way-hand-shaking 이 필요연결해제를 할 때 바로 해제하는것이 아니라 약간의 시간을 두고 해제함(늦게 도착하는 패킷이 있기때문)-출처- (우아한테크-수리님)https://www.youtube.com/watch?v=BEK354TRgZ8&amp;t=100s"
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 5주차 회고",
    "url": "/posts/week5/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-12-17 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 5주차 회고내용(벌써 시작한지 한달이다)1. 전반적인 느낀 점 (일주일 동안 한 일)이번 한 주는 자바라는 언어와 친해지는 한 주였다.자바가 처음이라서인지 손에 잘 잡히지않아서 무언가를 좀 해보려하는데, 일단 되는게 없다. (근데 또 뭔가를 붙여서 어거지로 되게 한다)그리고 수업은 자바의 핵심이라고 할 수 있는 컬렉션...",
    "content": "한화시스템 BEYOND 캠프 3기 5주차 회고내용(벌써 시작한지 한달이다)1. 전반적인 느낀 점 (일주일 동안 한 일)이번 한 주는 자바라는 언어와 친해지는 한 주였다.자바가 처음이라서인지 손에 잘 잡히지않아서 무언가를 좀 해보려하는데, 일단 되는게 없다. (근데 또 뭔가를 붙여서 어거지로 되게 한다)그리고 수업은 자바의 핵심이라고 할 수 있는 컬렉션과 객체지향의 꽃인 클래스가 진행이 되었는데 내가 할 수 있는건 아무것도 없었다.그래서 앞으로는 자바와 친해지기로 정했다.그런데 이 친구 참 어렵다.컬렉션을 배우는 주간이라서 컬렉션에 대해 이해를 해보려했지만 참 이해하기 어렵다.그리고 이번주 수업동안 가장 큰 충격은 무엇보다 자바에서는컬렉션에 대해 인덱스 접근이 안되는것을 알았다 (왜 너만 접근안돼?)올해는 자바라는 친구와 가까워지기는 어려운거같고내년에 좀 더 친해질 수 있도록 노력해야겠다List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"자바\");var a = list[0]; // 이 부분이 안된다!2. 좋았던 점 (좋았거나 내가 잘했던 점)수업과는 별도로 개인적으로 자바라는 언어를배우며 정리하고 있는데, 진짜 이 언어가 새삼 대단하다고 느낀다.(자바는 동기화부분이 정말 강력하다)유저로 하여금 최대한 쉽게 코드를 치게해주기위해 정말 많은 노력을 하고 자원을 어떻게하면 효율적으로 사용하게할 것인지에 대해서 연구를 했다는게 느껴진다. (고슬링 선생님 이제서야 알아야갑니다)++ 코드를 자세히 몰라도 적당히 적으면 알아서 인텔리제이에서 고쳐준다. 강사님이 정말 열정이 넘쳐서 강의를 진행할때마다 가끔씩 놀랜다내용이 한번씩 깊게 들어가서 '여기서 이 내용을 여기까지한다고요??' 지금처럼 시간이 있을때 한번씩 딮하게하는게 개인적으로는 좋다.3. 아쉬웠던 점한달이나 지났는데 뭔가 스스로의 발전이 느린느낌이다.진짜 노베이스로 처음부터 배운거치고는 많이 발전했지만, 아직까지 만족이 안든다.자바라는 언어와 웹이라는 도메인 자체에 손을 놨던게 후회가 되는 생각이 많이 들었다.4. 개선할 점문제에 대해서 너무 스스로 해결할려고하다보니 시간을 뭔가 아깝게 쓰는 경우가 많다는걸 느껴서 개선방법을 강구해봤는데, 나도 수강생의 입장으로 듣는것이니 강사님께 필요한 부분은 건의를 해서 거기에 대한 정보와 답을 얻는게 좋은거같아서 강사님을 적극적으로 활용해야겠다 (강사님 자주 찾아가겠습니다)그리고 코테에 대해서는 손을 놓은 상태였는데, 이야기를 한 뒤에 생각을 다시 해보고 점검을 해봤을 때다시 코테에 대한 부분을 점검해서 실력을 다시 키워야겠다고 느껴서코테에 대한 부분도 함께 병행해나가기로 함.5. 다음주 계획1. 객체지향에 대해 공부하기2. 수업때 진행되는 알고리즘에 대해 공부하기"
  },
  
  {
    "title": "자바 Thread_15",
    "url": "/posts/Java-Thread15/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-15 16:09:22 +0900",
    





    
    "snippet": "가상 스레드  시작 메서드를 실행하면 애플리케이션에 새로운 OS스레드를 만들어달라고 OS에 요청함  이후 JVM에 요청해 정해진 크기의 스택 공간을 할당받아 스레드와 로컬변수를 저장함 =&gt; OS는 CPU 스레드 스케줄링과 실행에 전적인 책임이 있음, JVM내부의 스레드는 얕은 계층, 혹은 운영체제 스레드를 감싸고 있는 것에 불과 (자바 스레드 =...",
    "content": "가상 스레드  시작 메서드를 실행하면 애플리케이션에 새로운 OS스레드를 만들어달라고 OS에 요청함  이후 JVM에 요청해 정해진 크기의 스택 공간을 할당받아 스레드와 로컬변수를 저장함 =&gt; OS는 CPU 스레드 스케줄링과 실행에 전적인 책임이 있음, JVM내부의 스레드는 얕은 계층, 혹은 운영체제 스레드를 감싸고 있는 것에 불과 (자바 스레드 == 플랫폼 스레드)  자바 플랫폼 스레드는 기본적으로 무거움(비용이 큼)그리고 OS스레드와 1:1 매칭된다(OS스레드가 JVM의 정적 공간에 묶여있음)——가상스레드는 JDK 21이상부터 사용가능  가상 스레드는 다른 스레드와 달리 우리가 동시에 실행하고 메서드를 시작할 코드를 가지고 있어야함  하지만 플랫폼 스레드와 달리 가상 스레드는 JVM에 완전히 속해서 JVM의 관리를 받음(고정 크기 스택으로 할당X)  운영체제는 가상 스레드를 생성하거나 관리하는 데 전혀 관여하지 않고 존재 자체를 모름      사실 가상 스레드는 힙 메모리에 할당된 다른 자바 객체처럼 더 이상 필요가 없어지면 JVM의 가비지 컬렉션에 의해 반환됩니다    이러한 사실의 결과로 플랫폼 스레드는 만들고 관리하는 비용이 많이 드는 반면, 가상 스레드는 저비용으로 빠르게 많은 양을 생성가상 스레드가 그냥 자바 객체라면 어떻게 실제로 CPU에 실행시킬까??”      우리가 엔진에 가상 스레드 하나를 생성하자마자 JVM은 비교적 작은 내부 플랫폼 스레드 풀을 만듭니다        그리고 이제 언제든 JVM이 특정 가상 스레드, 스레드 A를 실행시키려 하면 풀 내 플랫폼 스레드 중 하나에 마운트합니다        가상 스레드가 플랫폼 스레드에 마운트 되면 그 플랫폼 스레드는 캐리어 스레드라고 불립니다        이제 가상 스레드 실행이 끝나면 JVM은 캐리어에서 스레드 마운트를 해제하고 플랫폼 스레드를 다른 가상 스레드가 사용할 수 있게 합니다        이 가상 스레드 객체는 가비지가 됩니다, 가비지 컬렉션에서 청소를 하겠죠 하지만 특정 상황에서, 예를 들어 스레드 A가 안 끝났고 더 이상 진행할 수 없는 순간이 오면 JVM은 마운트를 해제하고 현재 상태를 힙에 저장합니다        이 상태에는 명령 포인터와 캐리어 스레드 스택의 스냅샷이 포함        이 지점에서 JVM은 플랫폼 스레드를 다른 가상 스레드에 마운트 할 수 있게 됩니다  - 예를 들어 스레드 B는 이후 스레드 A가 계속할 수 있을 때 JVM은 다음과 같은 일 중 하나를 합니다- 다른 플랫폼 스레드를 사용할 수 있으면 다른 가상 스레드를 이동하지 않고, 가상 스레드 A를 바로 마운트- 반면, 현재 가능한 플랫폼 스레드가 없다면 스레드 A는 대기- 스레드 B와 같이 캐리어 스레드로 실행되는 가상스레드 중 하나가 더 이상 진행되지 않으면 JVM은 캐리어 스레드에서 힙으로 상태를 복사해 스레드 B를 마운트 해제- 캐리어 스레드 명령 포인터를 사용해 스레드 A를 해당 캐리어 스레드에 마운트- 가상 스레드 A의 명령 포인터죠, 그리고 힙 메모리에서 스레드 A 스택 데이터의 스냅샷을 떠서 캐리어 스레드 스택 메모리로 다시 복사- 여기서 중요한 것은 우리 개발자들이 캐리어 스레드와 가상 스레드의 스케줄링을 거의 제어할 수 없음 (JVM이 내부적으로 우리를 위해 관리) &lt;br&gt;    private static final int NUMBER_OF_VIRTUAL_THREADS = 1000;    public static void main(String[] args) throws InterruptedException {        Runnable runnable = () -&gt; System.out.println(\"Thread\" + Thread.currentThread());        // NUMBER_OF_VIRTUAL_THREADS 수 만큼 스레드 리스트에 스레드를 담아 스레드를 실행함        List&lt;Thread&gt; virtualThreads = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; NUMBER_OF_VIRTUAL_THREADS; i++) {            Thread virutalThread = Thread.ofVirtual().unstarted(runnable);            virtualThreads.add(virutalThread);        }        for (Thread virtualThread : virtualThreads) {            virtualThread.start();        }        for (Thread virtualThread : virtualThreads) {            virtualThread.join();        }    // 개수를 늘려도 자기 컴퓨터의 스레드 개수를 넘지못함    private static final int NUMBER_OF_VIRTUAL_THREADS = 2;    public static void main(String[] args) throws InterruptedException {        List&lt;Thread&gt; virtualThreads = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; NUMBER_OF_VIRTUAL_THREADS; i++) {            Thread virutalThread = Thread.ofVirtual().unstarted(new BlockingTask());            virtualThreads.add(virutalThread);        }        for (Thread virtualThread : virtualThreads) {            virtualThread.start();        }        for (Thread virtualThread : virtualThreads) {            virtualThread.join();        }    }    private static class BlockingTask implements Runnable {        @Override        public void run() {            // 스레드를 재우기전 출력(마운트 해제전)            System.out.println(\"Inside thread \"+ Thread.currentThread() + \" before block call\");            try {                // 스레드를 1초간 재움                Thread.sleep(1000);            }catch (Exception e) {                throw new RuntimeException(e);            }            // 다시 가상스레드에 마운트            System.out.println(\"Inside thread \"+ Thread.currentThread() + \" after block call\");        }    }      sleep이 끝났을 떄 다른 플랫폼 스레드(캐리어스레드)에 마운트가 될 수 있음(스켈줄링 순서는 프로그램이 실행될때마다 달라질수있음)    개발자가 가상스레드를 관리리하고 스케줄링에 관여할 수 없음(OS가 알아서 관리함)      하나의 스레드가 sleep으로 들어가면 마운트해제하고 다른 가상스레드를 바로 실행하는것이 핵심!    가상스레드는 힙 메모리를 할당받는 객체와 유사!!가상 스레드를 통해 블로킹연산 성능을 어떻게 올리나??  작업 내용이 가상스레드가 CPU연산만 하는거라면 가상스레드는 어떤 성능 이득도 주지않음  여러 작업을 작은 풀에서 스케줄링 하는것임      가상 스레드로 실행하려는 코드에 스레드가 오랜 시간 기다려야하는 연산이 포함되어 있다면, 이상적으로 가상스레드는 성능측면에서 유리함    블로킹 연산이 있을때 스레드에서 실행되는지 확인함      만약 가상스레드라면 캐리어 스레드를 차단하지않고 가상스레드를 마운트 해제함 -&gt; JVM은 내부적으로 네트워크 연산의 논블로킹 버전을 사용함(복잡성은 비공개)        다른 사용자로부터 다른 요청이 오면 새로운 가상스레드를 만들어 처리함 (가상스레드 생성비용은 새로운 스택프레임이 필요없기에 상대적으로 가벼움)    시간이 지나 응답요청이 오면 첫번쨰 가상스레드를 다시 마운트하고 멈췄던 지점부터 코드를 실행함 -&gt; 이후 완료되면 GC에 의해 정리됨  논블로킹으로 처리가 되면 운영체제가 스케줄링에 참여하지않았기에 컨텍스트 스위치가 일어나지않음 =&gt; 그저 다른 가상 스레드에 속한 다른 조각의 코드를 찾아 실행을 계속해나갈뿐임  차단된 가상 스레드 마운트해제하고 새 가상스레드를 생성하고 마운트하는게 컨텍스트 스위치보다 비교적 좋음  가상 스레드의 이점은 블로킹 IO 연산을 훨씬 넘어서고, 긴 블로킹 연산들이 가상 스레드를 지원하기 위해 다시 개발되었고 캐리어 스레드가 발생하면 이를 해제함private static final int NUMBER_OF_TASK = 10000;    public static void main(String[] args) throws InterruptedException {        System.out.println(\"NUMBER_OF_TASK = \" + NUMBER_OF_TASK);        long start = System.currentTimeMillis();        performTask();        System.out.println(\"Tasks took to Complete\" + (System.currentTimeMillis() - start));    }    private static void performTask() {        try (ExecutorService executorService = Executors.newCachedThreadPool()) {            for (int i = 0; i &lt; NUMBER_OF_TASK; i++) {                executorService.submit(() -&gt; blockingIoOperation());            }        }    }    private static void blockingIoOperation() {        System.out.println(\"blocking task from thread: \" + Thread.currentThread());        try {            Thread.sleep(1000);        }catch (Exception e) {            throw new RuntimeException(e);        }    }  플랫폼 스레드 풀에서 동시에 10000개 작업을 실행  작업 단위 스레드 모델을 사용할떄 캐시 스레드풀을 사용하면 애플리케이션이 충돌함 -&gt; OS가 플랫폼 스레드를 더 많이 할당하는 것을 거부private static void performTask() {        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {            for (int i = 0; i &lt; NUMBER_OF_TASK; i++) {                executorService.submit(() -&gt; blockingIoOperation());            }        }    }  작업단위 가상 스레드 -&gt; 발생하는 모든 작업에 대해 새로운 가상 스레드를 생성 (i5-1135G7 기준 2초걸림)  내부적으로 사용자의 CPU 스레드수만큼만 만들어서 작업을 처리함public class Main {    private static final int NUMBER_OF_TASK = 10000;    public static void main(String[] args) throws InterruptedException {        System.out.println(\"NUMBER_OF_TASK = \" + NUMBER_OF_TASK);        long start = System.currentTimeMillis();        performTask();        System.out.println(\"Tasks took to Complete\" + (System.currentTimeMillis() - start));    }    private static void performTask() {        try (ExecutorService executorService = Executors.newFixedThreadPool(1000)) {            for (int i = 0; i &lt; NUMBER_OF_TASK; i++) {                // 1초를 맞추기위해 10ms를 * 1000함                 executorService.submit(new Runnable() {                    @Override                    public void run() {                        for (int j = 0; j &lt; 100; j++) {                            blockingIoOperation();                        }                    }                });            }        }    }    private static void blockingIoOperation() {        System.out.println(\"blocking task from thread: \" + Thread.currentThread());        try {            // 슬립을 10ms으로 줄임            Thread.sleep(10);        }catch (Exception e) {            throw new RuntimeException(e);        }    }  해당 코드를 1000개 고정 스레드로 실행하면 10초가 아니라 그 이상의 시간이 걸림 =&gt; 이 현상이 블로킹으로 인해 컨텍스트 스위치가 일어나는 높은 부하이며, 플랫폼스레드가 너무 많아 스레싱현상이 나타남private static void performTask() {        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor        // 스레드풀 크기를 작업마다 가상스레드를 생성하게 만들어줌        ()) {            for (int i = 0; i &lt; NUMBER_OF_TASK; i++) {                executorService.submit(new Runnable() {                    @Override                    public void run() {                        for (int j = 0; j &lt; 100; j++) {                            blockingIoOperation();                        }                    }                });            }        }    }      해당 코드를 실행하게되면 가상스레드를 생성하고 마운트, 해제하는 과정이 컨텍스트스위치보다 빠르다는 것을 알 수 있게됨(훨씬 가벼움)    가상스레드는 IO 바운드 애플리케이션에 가장 적합      코어 단위 스레드 모델을 논블로킹IO로 구현하면 비슷한 성능을 낼 수 있음      가상스레드 모범 사례      가상스레드를 사용할 시 가장 중요한 점은 CPU연산만 포함한 작업에서는 성능이점이 없음 -&gt; 이런 상황에서 스면 간접접근밖에 안됨, 이런한 점때문에 가상스레드라는 개념이 추가되고 기존 플랫폼스레드와 함께 있음    가상 스레드가 대기 시간 측면에서 전혀 이점이 없음      가상 스레드를 사용해 얻는 유일한 이점은 처리량 증가임    짧고 빈번한 블로킹 호출과 함께 작업 단위 스레드 모델을 사용하면 컨텍스트 스위치 비용이 발생함 그러나 가상 스레드를 사용하면 JVM에서 가상 스레드를 마운트하고 해제하는 비용만 발생함BEST Pracitce  가상 스레드를 고정 크기로 만들 수 없음      좋은 방법은 Executors.newVirtualThreadPerTaskExecutor() 통해 작업 실행자마다 새로운 가상 스레드를 실행하는것임    가상 스레드가 항상 데몬스레드 !  즉 가상 스레드는 애플리케이션이 종료되는 것을 절대 막지못함      가상 스레드의 우선순위를 설정하는것은 아무차이없고 설정한 값도 무시됨    디버깅할때 가상 스레드가 캐리어 스레드위에서 실행되고 있는 사실은 숨겨짐  디버깅 도구나 개발환경을 활용해 기존 스레드와 동일하게 해야함 (대신 디버깅이 진짜 어려움, 가상 스레드가 몇개가 생길지모름)출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_14",
    "url": "/posts/Java-Thread14/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-15 16:09:22 +0900",
    





    
    "snippet": "논-블로킹자바 스레드12 ~ 13의 내용와 이어지는 내용으로 꼭 두 개의 글을 같이 봐야함  논블로킹을 호출하면 해당 메서드는 차단되지않음  바로 반환하기때문에 스레드가 다음 작업을 할 수 있음(결과를 인자로 받는 콜백 함수)  요청을 처리하는 스레드가 차단되지않았기에 코어보다 많은 스레드를 생성할 필요가 없음  CPU를 쉴틈없이 사용중이니 컨텍스트 ...",
    "content": "논-블로킹자바 스레드12 ~ 13의 내용와 이어지는 내용으로 꼭 두 개의 글을 같이 봐야함  논블로킹을 호출하면 해당 메서드는 차단되지않음  바로 반환하기때문에 스레드가 다음 작업을 할 수 있음(결과를 인자로 받는 콜백 함수)  요청을 처리하는 스레드가 차단되지않았기에 코어보다 많은 스레드를 생성할 필요가 없음  CPU를 쉴틈없이 사용중이니 컨텍스트 스위치도 없음  그러면 스레드를 더 생성할 이유는 코어가 더 많아서 병렬처리할떄임  논블로킹IO 사용시 코어수 == 스레드수 모델 가능함(CPU 연산을 수행하는 프로세스에 최적의 성능을 뽑아낼 수 있음)  단점은 코드 가독성이 블로킹IO에 비해 너무 안좋고 적용하는 코드의 레벨이 너무 높음 (매우 어려움)  대부분 라이브러리 or 프레임워크를 사용함 (netty, webflux 등등) 복잡도, 의존도 증가!블로킹IO, 논블로킹IO의 장점을 다 가진 스레드 모델이 있음 =&gt; 다음 글에출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_13",
    "url": "/posts/Java-Thread13/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-15 12:09:22 +0900",
    





    
    "snippet": "작업당 스레드 / 요청당 스레드자바 스레드12의 내용와 이어지는 내용으로 꼭 두 개의 글을 같이 봐야함// 실행할 작업의 수private static final int NUMBER_OF_TASK = 1000;    public static void main(String[] args) {        System.out.println(\"Enter to ...",
    "content": "작업당 스레드 / 요청당 스레드자바 스레드12의 내용와 이어지는 내용으로 꼭 두 개의 글을 같이 봐야함// 실행할 작업의 수private static final int NUMBER_OF_TASK = 1000;    public static void main(String[] args) {        System.out.println(\"Enter to start\");        Scanner sc = new Scanner(System.in);        sc.nextLine();        long start = System.currentTimeMillis();        performTask();        System.out.println(\"task from Thread: \" + (System.currentTimeMillis() - start));    }    private static void performTask() {      // 동적 스레드풀      // 작업을 완료하는데 필요한 스레드를 계속 생성하고 캐시로 저장해 나중에 재사용함 (현실적 - 작업량이 얼마나인지 모르고, 몇 개의 스레드를 미리 할당해야할지도 모름)      ExecutorService executorService = Executors.newCashedThreadPool();        // 최대 스레드풀의 최대 숫자를 정할 수 있음        //ExecutorService executorService = Executors.newFixedThreadPool(1000);                for (int i = 0; i &lt; NUMBER_OF_TASK; i++) {            // 반복할때마다 스레드 풀에 있는 스레드중 하나에서 새로운 작업이 실행됨            //executorService.submit(() -&gt; blockingIoOperation());            // 작업 하나당 블로킹을 호출하는게 아니라,블로킹 호출을 100번 실행함(10ms x 100 = 1000ms)             executorService.submit(new Runnable() {                @Override                public void run() {                    for (int j = 0; j &lt; 100; j++) {                        blockingIoOperation();                    }                }            });        }        executorService.shutdown();    }    private static void blockingIoOperation() {        System.out.println(\"블로킹 스레드 - \" + Thread.currentThread());        try {            Thread.sleep(10);        } catch (Exception e) {            throw new RuntimeException(e);        }    }  100번의 블로킹 연산을 통해 99번의 context switch가 일어남  컨텍스트 스위치로 인해 발생하는 부하는 생각보다 많은 시간을 소모하고 실제 예상한 1000ms보다 시간이 더 걸림.  장점은 작업 단위 스레드 모델이 성능과 H/W 성능 향상됨  모든 작업을 동시에 수행이 가능하고 작업 속도가 빠름(코어수 == 스레드수 보다 더 빠름)  단점은 스레드가 비용이 큰 리소스  생성할 수 있는 스레드수는 제한적임  블로킹 호출 대기만 해도 스택메모리와 다른 자원을 소모함  스레드를 많이 할당하면 충돌함, 작게 할당하면 원하는만큼 처리량이 안나옴(CPU를 효율적으로 사용못함)컨텍스트 스위치 비용  OS는 CPU를 효율적으로 쓸려고 노력함  블로킹을 감지하면 차단된 스레드의 스케줄링을 취소하고 진행가능한 다른 스레드를 찾음스레싱  OS가 시스템을 관리하는데 CPU 자원 대부분을 소모하고 그 다음에 스레드가 작업을 하는 상황을 스레싱이라 함(피해야하는 상황!!!)출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_12",
    "url": "/posts/Java-Thread12/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-15 12:09:22 +0900",
    





    
    "snippet": "블로킹 IO  공유 자원에서 경합하는 두 개의 스레드가 있는 경우  스레드1이 잠금을 얻으면 스레드2는 차단당하고 대기해야함 그러면 OS는 스레드2 예약을 취소하고 잠금이 해제되면 다시 예약함  =&gt; 시간이 짧더라도 성능에 영향을 줌  IO란?  컴퓨터 구조는 CPU, 메모리가 함께 있고 키보드, 마우스, 모니터, 하드 등 주변장치는 외부장치로 ...",
    "content": "블로킹 IO  공유 자원에서 경합하는 두 개의 스레드가 있는 경우  스레드1이 잠금을 얻으면 스레드2는 차단당하고 대기해야함 그러면 OS는 스레드2 예약을 취소하고 잠금이 해제되면 다시 예약함  =&gt; 시간이 짧더라도 성능에 영향을 줌  IO란?  컴퓨터 구조는 CPU, 메모리가 함께 있고 키보드, 마우스, 모니터, 하드 등 주변장치는 외부장치로 간주함  이런 이유는 cpu가 언제든지 메모리에 직접 접근할 수 있기 때문  프로그램은 운영체제 개입 없이 메모리에서 변수를 읽거나 쓸수있음      그러나 CPU는 직접 하드웨어에 접근할 수 없음. =&gt; 장치마다 있는 컨트롤러와 통신해 데이터를 송수신해야함.    CPU에 인터럽트가 발생하면 장치에서 작업 결과를 읽는데 관여함 그리고 컴퓨터는 DMA를 통해 CPU 개입없이 메모리에 읽기,쓰기 권한을 장치에 부여할 수 있음 (프로세스 실행가능)  통신이 초기화되거나 준비된 데이터가 인터럽트를 발생하면 그 때 CPU가 관여함  스레드풀을 유지함으로 애플리케이션 전체 기간동안 같은 스레드를 재사용할 수 있음. =&gt; 새 작업이 있는 동안 스레드를 만들고 시작하고 종료하는 부하를 줄여줌. 그리고 최적의 크기는 컴퓨터의 코어수가 동일하게 설정하면 됨  그러면 OS가 각 스레드를 별도의 코어에 예약하고 해당 스레드를 완전히 병렬로 실행하기에 하드웨어를 완전히 활용가능함.  중요한것은 항상CPU에서 실행되는 작업만 포함됨(블로킹 호출X)온라인 상점 웹 애플리케이션의 시나리오를 살펴볼게요  웹 애플리케이션은 각자 다른 상품 카테고리에 관심을 보이는 여러 사용자에게서 들어오는 HTTP 요청을 수신합니다  요청을 받으면 고객 요청을 읽은 다음 데이터베이스에 연결해현재 가능한 제품 목록과 리뷰, 가격을 읽어옴  데이터베이스에서 정보를 다 받으면 웹 페이지로 정보를 다시 보내 사용자가 볼 수 있게 합니다          간단하게 하기 위해 이 애플리케이션이 단일 코어 컴퓨터에서 돌아간다고 해봅시다      스레드의 수를 코어 수와 동일하게 유지하는 정책을 그대로 따른다면 우리 스레드는 한 개가 되겠죠      클라이언트의 요청을 파싱하고 사용자에게 응답을 보내주는 것은 간단합니다        반면 다른 컴퓨터에서 실행되는 원격 데이터베이스에 연결해서 복잡한 쿼리가 완료되기를 기다리는 데는 꽤 오랜 시간이 걸릴 겁니다  나아가 스레드가 차단된 동안 블로킹 IO 연산이 일어나며 이는 CPU 유휴 상태라고 함 =&gt; 이런 유형의 애플리케이션을 IO 바운드 애플리케이션이라고 합니다, 왜냐하면 대부분의 시간을 CPU 사용에 소모하기보다 IO에 소모하기 때문입니다  이 시간 동안 새로운 요청이 들어오면 코어가 하나만 있더라도 사실 CPU에는 여유가 있습니다  하지만 하나의 스레드만 허용하고 긴 IO 연산 때문에 차단된 상태라 새로운 요청은 첫 번째 요청이 끝날 때까지 네트워크 카드 큐에 들어가게 됩니다  이러한 IO 바운드 애플리케이션은 산업에서 매우 흔히 보이는 유형임대부분의 웹사이트를 구성하는 웹 애플리케이션은 사실 IO 바운드 애플리케이션  대부분의 시간을 사용자 요청에 응답이 오기를 기다리는 데 사용  원격 서비스나 데이터베이스에서 오거나, HTML, CSS, JavaScript를 로컬 디스크에서 불러오는 것빅데이터 처리 및 트랜스포메이션 애플리케이션입니다  이러한 애플리케이션은 데이터베이스에 저장할 데이터를 정제하고 준비하거나, 머신 러닝을 합니다  그리고 대부분의 시간을 큰 파일을 디스크에서 읽거나 다른 트랜스포메이션 애플리케이션에 결과를 전송하거나 다른 위치에 저장하는 데 필요한 IO에 사용합니다  하지만 IO 바운드 애플리케이션에서만 블로킹 IO가 문제가 되는 것은 아닙니다. 블로킹 IO의 문제점을 살펴보면 가끔씩 일어난다 해도 다른 시나리오가 있음멀티스레드 환경 온라인 상점 웹 애플리케이션(4코어 4스레드 가정)  하지만 이번에는 메모리에 일부 데이터를 저장해 두고 가끔 필요한 데이터가 메모리에 없을 때만 데이터베이스에 외부 호출을 합니다  시간 순으로 보면 첫 번째로 4명의 서로 다른 사용자에게서 4개의 요청을 받음  이중 3명은 애플리케이션 메모리에서 필요한 데이터를 찾았어요  그래서 짧은 시간에 작업을 완료했고 요청 하나만이 애플리케이션이 데이터베이스에 요청을 해야 합니다, 긴 시간이 걸리겠죠  이제 두 번째로 4명의 다른 사용자에게 4개의 요청이 들어왔습니다  하지만 지금은 4개가 아닌 3개 스레드만 사용 가능합니다, 왜냐하면 첫 번째 스레드는 이 IO 연산 때문에 여전히 차단된 상태입니다  비슷하게 이중 3개의 요청은 외부 호출 없이 완료되었다고 가정하고 배치 중 네 번째 호출만이 데이터베이스에서 데이터를 가져와야 한다고 해봅시다  이제 두 개의 스레드가 IO로 차단되었고 향후 요청을 처리할 스레드는 두 개밖에 없음. 요청을 처리할 수 있는 스레드는 빠르게 줄어들고 1개가 아니라 4개의 CPU 코어가 있어도 아무것도 하지 못함  IO 바운드 애플리케이션의 앞선 시나리오와 달리 이 경우에는 요청 중 몇 개만 처음에 데이터베이스 연결이 필요하죠예시를 통해 알 수 있는 점  우리 작업이 어떤 유형의 블로킹 호출을 포함할 경우 코어 수만큼 최대한 스레드 풀을 가동해도 CPU를 최대로 활용하지 못하고 최선의 성능을 내지 못합니다          CPU는 대부분의 시간을 유휴 시간으로 사용했습니다        블로킹 호출이 몇 개 없더라도 전체 애플리케이션 성능에 영향을 주며 블로킹 호출이 필요한 작업뿐 아니라 모든 호출이 영향을 받게 됩니다          몇 개의 요청만이 원격 데이터베이스 접근이 필요했는데도 다른 사용자의 요청도 CPU를 점유하지 못하게 막아버렸어요             IO 연산 시간 동안 CPU은 관여하지 않으며 다른 작업이 있다면 수행할 수 있는 상태        블로킹 호출을 포함하는 작업을 수행할 때 코어 수만큼 스레드를 만드는 정책을 따라도 하드웨어 활용률이나 성능을 최적화하지 못함  출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_11",
    "url": "/posts/Java-Thread11/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-14 20:09:22 +0900",
    





    
    "snippet": "원자적 레퍼런스public static class StandardStack&lt;T&gt; {        private StackNode&lt;T&gt; head;        private int counter = 0;        public synchronized void push(T value) {            StackNode&lt;...",
    "content": "원자적 레퍼런스public static class StandardStack&lt;T&gt; {        private StackNode&lt;T&gt; head;        private int counter = 0;        public synchronized void push(T value) {            StackNode&lt;T&gt; newhead = new StackNode&lt;&gt;(value);            newhead.next = head;            head = newhead;            counter++;        }        public synchronized T pop() {            if(head == null) {                counter++;                return null;            }            T value = head.value;            head = head.next;            counter++;            return value;        }        private static class StackNode&lt;T&gt; {            public T value;            public StackNode&lt;T&gt; next;            public StackNode(T value) {              this.value = value;              this.next = next;            }        }    }  동기화를 안썻다면 push와 pop의 헤드를 바꾸는 곳에서 경쟁상태가 일어나 다른스레드가 읽기와 쓰기 연산사이에 헤드의 값을 바꿀수있어 원자성이 보존안될 가능성이 매우큼    public static class LockFreeStack&lt;T&gt; {        // AtomicReference를 통해 객체를 원자적으로 만들 수 있음.        private AtomicReference&lt;StackNode&lt;T&gt;&gt; head = new AtomicReference&lt;&gt;();        private AtomicInteger counter = new AtomicInteger(0);        public void push(T value) {            StackNode&lt;T&gt; newhead = new StackNode&lt;&gt;(value);            // 많은 스레드가 동시에 푸시하는 상황이기에 정상적으로 성공하려면 여러번 시도를 해야하기때문             while (true) {              // get()을 통해 현재 스택의 헤드를 가져옴.                StackNode&lt;T&gt; cruuent = head.get();                // 새로운헤드의 다음 노드를 기존노드를 가리키게함                newhead.next = cruuent;                // 그런데 AtomicReference 헤드는 계속 current 헤드를 가리키고 있음                // compareAndSet()를 통해 현재 헤드의 값과 같으면 새로운 헤드를 할당함                if(head.compareAndSet(cruuent, newhead)){                    break;                } else{                  // 실패하면 아주 약간 쉼                    LockSupport.parkNanos(1);                }            }            counter.incrementAndGet();        }        public T pop() {            StackNode&lt;T&gt; current = head.get();            StackNode&lt;T&gt; newHead;            while (current != null) {                // push 메서드의 반대로임                newHead = current.next;                if(head.compareAndSet(current,newHead)){                    break;                } else {                    LockSupport.parkNanos(1);                    current = head.get();                }            }            counter.incrementAndGet();            return current != null ? current.value : null;        }        public int getCount() {            return counter.get();        }    }  현재 헤드 값을 읽은 다음, 해당 값을 기반으로 헤드를 대체할 새 후보자 값을 계산하고 방금 읽는값이 안변해야함  compareAndSet() 사용해 예상값이 여전히 같은지 확인하고 새로운 값을 할당  만약 예상값이 틀렸다면 false를 반환해 else를 만나서 다시 새롭게 프로세스를 반복      중요한것은 락을 쓰는거보다 원자적 객체일떄 항상 성능이 더 좋은것은 아님 !!        위의 코드를 비교하면 성능차이가 나는것을 알 수 있음.  출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_9",
    "url": "/posts/Java-Thread9/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-14 12:09:22 +0900",
    





    
    "snippet": "Lock Free 알고리즘 - 데이터 구조 및 기술      멀티 스레드 프로그래밍의 대부분이 락으로 이뤄지고병행성 문제 대부분을 락으로 쉽고 안전하게해결할 수 있습니다 락은 오랫동안 사용되어 왔으며H/W, S/W 큰 도움이 되어 왔습니다        경쟁 상태와 데이터 경쟁과 같은 모든 병행성 문제를 락을 사용으로 해결가능        그러나 엔지니...",
    "content": "Lock Free 알고리즘 - 데이터 구조 및 기술      멀티 스레드 프로그래밍의 대부분이 락으로 이뤄지고병행성 문제 대부분을 락으로 쉽고 안전하게해결할 수 있습니다 락은 오랫동안 사용되어 왔으며H/W, S/W 큰 도움이 되어 왔습니다        경쟁 상태와 데이터 경쟁과 같은 모든 병행성 문제를 락을 사용으로 해결가능        그러나 엔지니어는 항상 절충을 하게 됩니다  대부분의 문제에는 솔루션이 둘 이상 존재함 (진짜 억까가 아니라면)따라서 사용할 수 있는 도구가 많을수록 작업에 맞는 도구를 선택할 수 있죠옳은 도구를 선택하면 좋은 엔지니어가 될 수 있음  1. 데드락  애플리케이션에 발생할 수 있는 문제 중 가장 짜증 나는 것일 겁니다데드락 검출과 해결 로직을 구현할 노력과 시간이 없으면 데드락은 해결할 수 없습니다데드락으로 애플리케이션이 완전히 멈출 수 있고애플리케이션에 락이 많을수록 데드락이 걸릴 확률이 높습니다2. 다른 문제로 같은 락을 사용하는 멀티 스레드가 있는 경우  스레드 하나가 나머지보다 락을 더 오래 가지고 있을 수 있습니다  스레드 하나만 같은 락으로 보호되는 임계 영역에 들어갈 수 있는데긴 임계 영역이 다른 스레드를 느리게 할 수 가능성이 있음  따라서 나머지 스레드가 전부 가장 느려지는 상황에 처하게 됩니다3. 우선순위 역전  리소스 하나와 그 리소스의 락을 공유하는 스레드가 두 개일 때 생기는 문제입니다  스레드 하나가 운영체제에 의해 낮은 우선순위를 갖게 되는 것이죠          예를 들어 백그라운드 문서 저장이 낮은 우선순위를 갖고 사용자 인터페이스가 높은 우선순위를 갖는 것이죠      스레드에 부여된 이 우선순위로 높은 우선순위의 스레드가 우선적 또는 자주 스케줄링됩니다                  만약 낮은 우선순위 스레드가 공유 락을 획득하고 운영체제에 의해 선택되면 어떻게 될까요?          우선순위 스레드는 이제 고립되는데 운영체제가 낮은 우선순위 스레드를 다시 충분히 스케줄링하지 않기에 락이 릴리스되지 않아 우선순위 스레드가 락을 획득하지 못해 진행하지 못합니다0          애플리케이션의 무응답성 문제뿐 아니라 실행 문제도 생기게 되죠 다른 운영체제가 장단점을 가진 다른 방법으로 이 문제를 해결할 수 있습니다                    4. 스레드가 락을 지닌 채 그냥 죽거나 인터럽트될 때 (찾을려면 사람이 미쳐버림)      우선순위 역전보다 더 심한 문제이다 모든 스레드가 영원히 정체되고 데드락처럼 상황은 회복되지 않을 확률이 매우 크다.        이를 방지하기 위해 개발자는 모든 중요 영역을 타임아웃을 지닌 tryLock을 사용해 try와 block하여 감싸는 등의 복잡한 코드를 쓰도록 요구됩니다        또 성능 오버헤드 문제가 있는데 락을 얻기 위한 스레드 간 다툼이 생겨요스레드 A가 락을 획득하면 스레드 B가 그 락을 가지려 해 스레드 B가 블록됩니다 그 결과 다음과 같습니다                  스레드 B가 블록되어 스레드 B에서 다른 스레드로의 컨텍스트 스위치가 일어나는데, 락이 릴리스될 때 스레드 B를 가져오는 오버헤드가 일어나게 됨.                    이런 오버헤드와 지연 시간은 애플리케이션 대부분에서 감지하지 못하지만 밀리초보다 짧은 지연 시간으로 연산하는 초고속 거래 시스템 같은 애플리케이션 같은 경우 이런 오버헤드는 고려해야 할 중요 요소입니다              락에 대한 대안으로 무엇이 있을까요?우선 최초 락이 필요했던 주요 이유를 살펴봅시다문제의 핵심은 멀티 스레드가 리소스를 공유하고 최소 하나의 스레드가 리소스를 수정하여 원자적 연산이 되지 않은 것이죠  어떻게 원자적 연산이 되지 않은것인가?? 문제는 소프트웨어 추상화 스택의 가장 아래 단계에 있습니다Java 연산은 CPU에서 실행하는 하나 이상의하드웨어 연산으로 변하는데 예를 들어count++는 최소 세 개의 명령어로 변합니다          카운트 값을 읽어라      새로운 값을 계산하라      값을 카운트에 저장하라             여러 하드웨어 명령어의 실행 사이에다른 스레드가 카운트 값을 수정할 수 있습니다        따라서 lock free 프로그래밍은 연산을 활용하여단일 하드웨어 명령어로 실행될 수 있게 보증하는 것입니다단일 하드웨어 명령어는 의미상 원자적이라 스레드는 안전합니다    long/double을 제외한 모든 원시 유형, 모든 레퍼런스 그리고 volatile long/double의 Read/Assignment가 있습니다.  데이터 경쟁을 완전히 피하려면 락 없이읽고 쓸 수 있는 모든 공유 변수를 volatile로 하는 데동의할 수 있죠, 그러면 리스트가 짧아지고 쉽게 기억할 수 있습니다  원자적으로 실행할 수 있는 두 번째 연산은 JavaUtilConcurrentAtomic 패키지에 위치한 atomic 클래스에 있습니다  이 클래스는 직접 사용을 권하지 않는 비저장 Java 클래스를 활용하고 메서드 일부가 아키텍처가 제공하는원자적 연산을 포함한 낮은 단계의 플랫폼 특정 연산을 활용할 수 있는 native 메서드에 대한 접근을 제공합니다 (Java 10의 AtomicPackage에서 사용 가능한 클래스 목록입니다)  각 클래스는 매우 다양하면서 유용한 원자적 연산을제공하며 이런 원자적 연산을 사용해아주 강력한 lock free 알고리즘과 데이터 구조를 디자인할 수 있음출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_10",
    "url": "/posts/Java-Thread10/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-14 12:09:22 +0900",
    





    
    "snippet": "원자적 정수  원자적int initValue = 0;// 원자적 정수의 입력값을 생성자에 넣음AtomicIneger atomicIneger = new AtomicIneger(initValue);/* 둘 다 값을 1씩 증가시킴 */atomicIneger.incrementAndGet(); // 1을 더 한값을 반환atomicIneger.getAndIncr...",
    "content": "원자적 정수  원자적int initValue = 0;// 원자적 정수의 입력값을 생성자에 넣음AtomicIneger atomicIneger = new AtomicIneger(initValue);/* 둘 다 값을 1씩 증가시킴 */atomicIneger.incrementAndGet(); // 1을 더 한값을 반환atomicIneger.getAndIncrement(); // 현재값을 반환하고 값을 더함/* 둘 다 값을 1씩 감소시킴 */atomicIneger.decrementAndGet(); // 1을 뺀값을 반환atomicIneger.getAndDecrement(); // 현재값을 반환하고 값을 뺌/* 값을 더함 (+역할, -역할) */atomicIneger.addAndGet(5); // 값을 더하고 반환atomicIneger.getAndadd(5); // 기존값을 반환하고 더함  락이나 동기화가 필요하지않아 경쟁상태나 데이터 경쟁이 필요없음  단점은 메서드 자체가 원자적인데, 다른 연산과 함꼐 사용이 어려움Lock Free 이커머스synchronized 통한 원자성    public static void main(String[] args) throws InterruptedException {        InventoryCounter inventoryCounter = new InventoryCounter();                IncrementThread incrementThread = new IncrementThread(inventoryCounter);        DecrementThread decrementThread = new DecrementThread(inventoryCounter);        // 더하는 쓰레드 &amp; 빼는 쓰레드 각각 만번씩 실행        incrementThread.start();        decrementThread.start();        incrementThread.join();        decrementThread.join();                // 쓰레드가 synchronized 만나면 다른 스레드는 대기상태가 되기때문에 하나씩 실행이 되고 필드는 원자성을 확보하게되어 0이 출력        System.out.println(\"inventoryCounter.getItems() = \" + inventoryCounter.getItems());    }    public static class DecrementThread extends Thread{        private InventoryCounter inventoryCounter;        public DecrementThread(InventoryCounter inventoryCounter) {            this.inventoryCounter = inventoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                inventoryCounter.decrement();            }        }    }    public static class IncrementThread extends Thread {        private InventoryCounter inventoryCounter;        public IncrementThread(InventoryCounter inventoryCounter) {            this.inventoryCounter = inventoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                inventoryCounter.increment();            }        }    }    public static class InventoryCounter {        private int items = 0;        public synchronized void increment() {            items++;        }        public synchronized void decrement() {            items--;        }        public int getItems() {            return item;        }    }원자적 변수를 적용한 코드    public static void main(String[] args) throws InterruptedException {        InventoryCounter inventoryCounter = new InventoryCounter();        IncrementThread incrementThread = new IncrementThread(inventoryCounter);        DecrementThread decrementThread = new DecrementThread(inventoryCounter);        incrementThread.start();        decrementThread.start();        incrementThread.join();        decrementThread.join();                System.out.println(\"inventoryCounter.getItems() = \" + inventoryCounter.getItems());    }    public static class DecrementThread extends Thread{        private InventoryCounter inventoryCounter;        public DecrementThread(InventoryCounter inventoryCounter) {            this.inventoryCounter = inventoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                inventoryCounter.decrement();            }        }    }    public static class IncrementThread extends Thread {        private InventoryCounter inventoryCounter;        public IncrementThread(InventoryCounter inventoryCounter) {            this.inventoryCounter = inventoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                inventoryCounter.increment();            }        }    }    public static class InventoryCounter {        private AtomicInteger items = new AtomicInteger(0);        public void increment() {            items.incrementAndGet();        }        public void decrement() {            items.decrementAndGet();        }        public int getItems() {            return items.get();        }    }  락을 사용하지않아 복잡하게 하지않고 병력적으로 수행할 수 있음  원자적 연산을 할 떄에만 사용해야함 !!!  원자적 연산은 비원자적 연산을 보호하기 위해 락을 가진 일반 정수를 사용할때보다 더 성능이 좋음  단점은 싱글 스레드를 사용하게되면 일반 정수사용보다 느려질 수 있음출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_8",
    "url": "/posts/Java-Thread8/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-13 19:09:22 +0900",
    





    
    "snippet": "asd세마포어  허가하고 권한을 부여함.  사용자 수를 특정 리소스나 그룹을 제한하는데 사용 가능함.  리소스당 사용자 하나만 허가하는 락과 달리 세마포어는 사용자에게 리소스를 제한할 수 있음.  임계 영역이나 리소스마다 사용자 수를 제한할 수 있음  스레드간 통신을 위한 수단!!!!  ex) 주차장 빈공간과 대기열  Lock은 허가 한 개만 줄 수 ...",
    "content": "asd세마포어  허가하고 권한을 부여함.  사용자 수를 특정 리소스나 그룹을 제한하는데 사용 가능함.  리소스당 사용자 하나만 허가하는 락과 달리 세마포어는 사용자에게 리소스를 제한할 수 있음.  임계 영역이나 리소스마다 사용자 수를 제한할 수 있음  스레드간 통신을 위한 수단!!!!  ex) 주차장 빈공간과 대기열  Lock은 허가 한 개만 줄 수 있는 세마포어라고 생각하면 편함  허가를 얻다 = 리소스에 락 =&gt; 세마포어를 실행할때까지 다른 스레드는 세마포어를 얻을 수 없음!! 세마포어는 락과 특징이 다르기때문에 락처럼 사용하면 안됨 !!  소유자 스레드개념이 없음 -&gt; 다수의 스레드가 허가를 얻기 때문또한 스레드 하나가 세마포어를 여러번 얻을 수 있음 (초기값을 1로 맞춘 이진 세마포어는 블락)  어떤 스레드든 세마포어를 사용함(세마포어를 얻지않는 스레드도 릴리스함)생산자-소비자 시나리오 -&gt; 세마포어를 사용해야하는상황!!  CPU를 최대한 활용할 수 있도록 조절해야함!  스레드가 여러 개 있는 앱에 적용을 많이함  Actor 모델을 사용하는 스레드와 프레임워크간에 작업을 나눌 때 사용 -&gt; TCP, UDP 패킷을 사용한 소켓채널이 대응하는 핸들러에 전달  스레드간 통신 라이브러리나 프레임워크는 자주 사용함 (기본적으로 알고있으면 매우매우 좋음)  스레드간 통신을 통해서 단순한 생산자-소비자 시나리오 실행이 가능함스레드간 통신  세마포어는 조건 변수의 특별한 사례  스레드가 세마포어를 얻으려 하면 사용 가능한 권한의 수가 0보다 많은지를 확인하는것 -&gt; 다음 명령어로 넘어가기위한 스레드가 요구하는 조건 =&gt; 조건이 불충족하면 다른 스레드가 세마포어 상태를 변경할 때까지 기다림  다른 스레드가 실행되면 기존 스레드가 권한 조건이 충족되었는지 확인함 -&gt; 충족됐다면 다음 명령어를 계속 실행조건 변수 - 스레드 간 통신의 제네릭 방법  연속적인 스레드 실행을 명시하기 위해 원하는 모든 조건을 사용  스레드A가 조건 확인 -&gt; 안되면 현재 스레드를 정지하고 나중에 다른 스레드가 상태를 변경해 스레드A를 깨우는 신호를 보낼때까지 기다림  스레드A 조건이 충족되면 다음 단계로 넘어가 계속 실행 -&gt; 그러다 다시 조건이 안맞으면 기다리고 다른 스레드의 신호를 기다림    조건변수는 항상 Lock과 연관되어있음 !!    락은 조건 확인과 조건에 들어있는 공유 변수의 수정이 원자적으로 실행되었는지 확인하는데 사용생성자-소비자 시나리오 !  두 개의 스레드          UI스레드로 이름, 암호 부여      이름과 암호를 디비에서 검색하고 인증여부 확인        디비에서 검색하는데 시간이 오래걸리고 1번 스레드에서 확인이 어려움Lock lock = new ReentrantLock();Condition condition = lock.newCondition();String username = null, password = null; // 공유변수/* 인증스레드 */lock.lock(); // 락을 얻고try {    // 변수가 값을 얻었는지 확인후, 없으면 다른 스레드가 깨울때까지 슬립함 (await로 인해 깨울때까지 기다림 -&gt; lock을 원자적으로 언락함)    while(username == null || password == null) {        condition.await();    }}finally {    lock.unlock();}/* UI스레드 */lock.lock(); // 인증스레드가 잠기면 락을 얻음try {    // 사용자가 입력안하면 null이 되고, 입력하면 인증스레드에서 await된 스레드를 깨우기위해 signal 호출    username = geName();    password = getPassword();    condition.signal();}finally {    lock.unlock(); // 언락이 실행될때까지 인증스레드는 락을 얻지못함}  await메서드는 스레드를 완전히 슬립시켜 다른 스레드가깨울때까지 CPU를 포기함  signal메서드는 조건변수에서 기다리는 스레드를 깨우는데, 조건 변수에서 기다리는 스레드가 하나 이상일 때 하나만 깨어나고 나머지는 계속 슬립 -&gt; 깨어난 스레드는 조건 변수와 연관된 lock을 다시 얻어야함.  조건 변수에 기다리는 스레드가 없을 때는 신호가 가는 스레드도 없음 (세마포어와 조건 변수의 아주 중요한 동작 차이)  조건 변수가 신호를 받는 사실이 어느곳에도 저장되지않음!!스레드간 통신 - 방법 2  Java의 모든 객체 클래스에는 wait(), notify(), notifyAll()가 존재함  어떤 유형의 객체에서도 해당 메서드를 호출할 수 있음 =&gt; 프로그램의 어떤 객체라도 조건 변수로 사용이 가능함  synchronized 키워드를 사용해 모든 객체를 Lock으로 사용할 수 가능해 스레드 간 통신에 모든 객체 사용 가능함          wait() =&gt; 다른 스레드가 깨어날 때까지 현재 스레드를 기다리게 함              wait 상태에서는 스레드가 CPU를 사용하지않음                  notify() 통해서 현재 객체에서 대기하는 단일 스레드를 깨우고, 여러 스레드가 객체에서 대기하면 임의로 한개만 깨어남          notifyAll() 호출하면 객체의 모든 스레드를 깨움                          전제조건은 꼭 객체를 동기화해야함 !!  public class mainClass {    // 완료 상태를 나타내는 변수    private boolean isComplete = false;    public void waitUntilComplete() {        synchronized(this) {            // 참이 아니면 스레드는 wait상태가 되고 CPU를 포기함            while(isComplete == false) {                this.wait();            }        }    }    public void complete() {        synchronized(this) {            // 이후 해당 객체로 오게되면 조건변수를 참으로 변경후 wait상태 스레드를 깨움            isComplete = true;            this.notify();        }    }}// 현재 객체만을 사용할거면 함수 synchronized 선언가능출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 4주차 회고",
    "url": "/posts/week4/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-12-10 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 4주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)본격적인 자바 수업에 들어간 한 주였다.인텔리제이와 자바를 설치하고 Hello World를 출력했을때학부생떄의 과거가 떠올라서 감회가 새로웠다. 지금까지는 자바를 보면서 안좋은점에 대해서 많은 생각을 가지고 있었는데, 다시 해보니 내가 생각했던거보다는 쫌 편한...",
    "content": "한화시스템 BEYOND 캠프 3기 4주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)본격적인 자바 수업에 들어간 한 주였다.인텔리제이와 자바를 설치하고 Hello World를 출력했을때학부생떄의 과거가 떠올라서 감회가 새로웠다. 지금까지는 자바를 보면서 안좋은점에 대해서 많은 생각을 가지고 있었는데, 다시 해보니 내가 생각했던거보다는 쫌 편한거같다는 생각이 들었다. 실제로 자바는 거의 처음하는거랑 다름없어서 초심자의 마인드로 새롭게 배우고 있어서 기초부터 차근차근 배워나가야겠다고 느낀 한 주였다.2. 좋았던 점 (좋았거나 내가 잘했던 점)진짜 자바라는 언어 자체에 대한 레퍼런스를 찾을 때자료가 쏟아질정도로 많다. 구글 검색이 아니라, 네이버에서 검색해도 어느정도 필요한 내용은다 찾을 수 있어서 대한민국이 자바공화국이라는게 새삼 느낀다.내가 빨리 배우고자한다면 자료들을 정리해둔것이 많이 있어서그거만따라가도 선행학습이 절로되겠다고 느낀다.그리고 인텔리제이 무료버전도 생각보다 나쁘지않은거같다 ㅎ3. 아쉬웠던 점자바라는 언어 자체에 대한 레퍼런스를 찾을 때진짜 자료가 쏟아질정도로 많은데 정확하지않은 내용도 있고,사람마다 다 스타일이 다른건지 시원하게 딱 알려주는것이 없는거같다.흔히 말하는 best practice 라는게 정말 부족하다고 느꼈다.오라클 독스에서 설명은 해주지만, 최소한의 정의만 해주지사용자에게 정말 불친절하게 적혀있고 내용도 부족하다 (문서화가 부족함)자기들이 인수를 했으면 제대로 관리를 해야지, 너무할정도로 느낀다.그래도 내가 선택한 자바인데 열심히해야지라는 생각으로 위와 같은불만사항들을 이겨내야한다. 4. 개선할 점자바에 대해 지금보다 더 친숙해져야겠다고 느낀다.지금처럼 약간의 시간이 있을때 복습시간을 통해 제대로배워서 다음 단계로 넘어가야겠다고 느낌.5. 다음주 계획자바 기본문법까지 정리하기 !!강의 내용 복습하기 !!"
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 1개월차 회고",
    "url": "/posts/monthly_1/",
    "categories": "한화시스템, 월차회고",
    "tags": "hanhwa",
    "date": "2023-12-10 23:00:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 1개월차 회고내용1. 수강동기웹 개발자가 되기위해 다양한 부트캠프를 찾다가한화시스템에서 주최하는것을 보고 고민도 없이 일단 신청했다.그리고 엔코아에서 교육하는거다보니 데이터베이스 관련해서도깊게 배울 수 있을거같아서 망설임없이 지원했다2. 1개월 동안 학습한 기술셋 간단하게 정리- linux- Database (mari...",
    "content": "한화시스템 BEYOND 캠프 3기 1개월차 회고내용1. 수강동기웹 개발자가 되기위해 다양한 부트캠프를 찾다가한화시스템에서 주최하는것을 보고 고민도 없이 일단 신청했다.그리고 엔코아에서 교육하는거다보니 데이터베이스 관련해서도깊게 배울 수 있을거같아서 망설임없이 지원했다2. 1개월 동안 학습한 기술셋 간단하게 정리- linux- Database (mariaDB)- git, github- jira가장 재미없고 지루하지만, 개발자로서 꼭 필요한 기술스택이다보니 꾸준하게 정리하고 수업을 따라가서 내 것으로 익히려 노력했다.3. 전반적인 느낀 점흔히들 국비라고하면 강사님을 잘 만나야한다고하는데, 진짜 잘만났다.항상 수업준비를 꼼꼼하게 하시고, 부족한 부분을 채워넣고 어느정도는 딮하게 파고들어가는 수업내용이 개인적으로 너무 좋았다.그리고 수업내용 중 중요한것과 중요하지않은것을 적절하게 골라서중요한것은 시간을 좀 더 써서 확실하게 하고 넘어가려는 수업의 방향성이 나의 스타일과 잘 맞았다.또한 팀프로젝트를 했을 때 모든 인원들이 다 열심히해서첫 프로젝트인 데이터베이스 부분을 잘 마무리할 수 있었고, 프로젝트를 통해 수업때 배운 내용들을 정리를 잘 할수 있었던거같다.4. keep수업의 내용중 딮하게 들어가는 부분들이 있는데, 그런 키워드들은정말 중요한 것이니 복습할 때 다시 한 번 정리해서 완벽하게 숙지하고 다음 단계로 넘어가는것이 좋다고 생각한다5. Problem성향상 머리속으로만 내용을 이해하려는게 있다고 판단했다.손으로 적고, 블로그에 정리하고 해서 두번세번 머리에 내용을암기시키고, 그 다음 이해를 하던지해서 중요한 내용은 완벽하게숙지할 수 있도록 하자 !!!6. Try수업의 내용을 정리만하지말고, 한단계 더 높여서 직접 코드에녹여서 내가 직접 써보고 장단점을 느끼면 더 발전이 빠를거같다."
  },
  
  {
    "title": "자바 Thread_7",
    "url": "/posts/Java-Thread7/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-08 17:09:22 +0900",
    





    
    "snippet": "ReentrantLock  synchronized 키워드처럼 작동함  그러나 명확한 락킹과 언락킹을 명시해야함  단점은 공유된 리소스사용한 후 언락킹을 명시안했을때 데드락의 원인이 된다.  락킹, 언락킹을 명시하더라도 throwExceptionMethod로 인해 문제가 생기면 임계영역에서 에러가 났으니 언락이 호출 안 될 수도있음      이러한 문제...",
    "content": "ReentrantLock  synchronized 키워드처럼 작동함  그러나 명확한 락킹과 언락킹을 명시해야함  단점은 공유된 리소스사용한 후 언락킹을 명시안했을때 데드락의 원인이 된다.  락킹, 언락킹을 명시하더라도 throwExceptionMethod로 인해 문제가 생기면 임계영역에서 에러가 났으니 언락이 호출 안 될 수도있음      이러한 문제로 인해 락킹을 걸고 예외처리구문의 끝에 finally까지 만들면 임계영역에서 언락킹을 실행할 수 있게된다.    과정이 복잡하기 떄문에 우리는 락을 더 통제하고 수준높은 작업을 해야함      getQueuedThreads() 메서드를 통해 락을 기다리는 스레드 목록을 반환함        getOwner() 메서드는 락을 가지고 있는 스레드를 반환        isHeldbyCurrentThread() 현재 스레드에 락이 있으면 true를 반환    isLocked() 메서드는 스레드에 락이 있는지 없는지 알려줌      프로덕션 코드에 대한 테스트를 빡세게 해야하고, 복잡한 스레드를 테스트할떄 isLocked(), getQueuedZThreads() 를 사용하면 편리함.    락의 공정성을 제어할 때 가장 뛰어남  기본적으로 reentrantLock 및 동기화 키워드는 공정성을 보장하지 않음  ReentrantLock(ture) 으로 실제 값을 전달해서 공정성을 만들수있음  공정성을 유지하면 문제가 생김.  락을 얻으면 시간이 걸려 프로그램의 처리량이 줄어들 수 있음 =&gt; 꼭 필요할 때만 사용해야함  감시 장치를 실행할 때 LockInterruptibly()이 메서드를 사용하면 유용함  감시 장치로 데드락 스레드를 검출하고데드락 스레드에 인터럽트를 실시해 스레드를 복구하죠그리고 이 메서드를 사용해서 앱을 정상적으로 종료할 수 있음 -&gt; lock을 기다리는 스레드를 인터럽트로 꺠우고 종료tryLock()  어떤 경우에도 tryLock메서드를 차단하지 않음      lock 객체가 어떤 스레드에 있든 즉시 값을 반환    만약 실시간 앱에 사용한다면 기억해야할게있음  lock 메서드로 스레드를 중단할 순 없음 (영상, 사진, 속도가 빠른앱, 지연이 없는 시스템, GUI등)// lock 객체를 얻고 다른 스레드가 임계 영역에 못들어감// 다른 스레드 입장에서는 먼저 잡은 스레드때문에 lock이 걸려 진행을 못하게 됨lockObject.lock();try {    // 실행구문}finally {    lockObject.unlock();}// tryLock 메서드로 lock 객체를 얻음.// true 반환해 현재 스레드를 얻었다는것을 알 수 있음// 다른 스레드가 들어오더라도 lock객체를 얻지 못했으니 else 조건을 실행하면 됨.if(lockObject.tryLock());    try {        // 실행구문    }    finally {        lockObject.unlock();    }}else {    // 실행구문}  어떤 경우라도 tryLock 메서드를 차단하지않음  lock객체가 어떤 스레드에 있든 값을 반환함  ReentrantLock은 synchronized와 똑같은 특성과 기능을 가지고 있음  lock 객체를 테스트하기 위한 쿼리 메서드가 주요한 기능  lockInterruptibly() 으로 인터럽트  tryLock()  ReentrantReadWriteLock  ReadLock, WriteLock을 합쳐서 하나의 락으로 만든 것경쟁상태  리소스를 공유하는 스레드가 다양함  하나의 스레드는 리소스를 수정함해결방법은 상호배제  스레드가 공유 리소스를 읽기, 쓰기, 둘다해도 상관없음      임계영역을 통해 스레드 하나만 실행가능함    지금까지의 락은 스레드 여러개가 공유 리소스에 접근하는 것을 막음  읽기작업이 빠르고, 락이 경쟁상태를 막는 일도 거의 발생하지않음만약 캐시처럼 읽기작업을 주로 하거나, 읽기작업이 느릴경우??  변수를 여러개 읽기 작업하기 !  데이터 구조가 복합하면 작업이 느려짐          읽기 작업을 주로 하는 스레드 여러개가 공유 자원을 읽는 것을 막으면 성능 저하가 생김.      그래서 ReentrantReadWriteLock 사용 !!!  락 기능을 제공하지않음 -&gt; 쿼리메서드 !  내부 락이 두개 있는데, 읽기락(readLock)과 쓰기락(writeLock)이 있음  쓰기락을 통해 스레드가 임계영역에 접근하는 것을 막고 해당 영역에서 공유 리소스를 수정함  공유 리소스를 읽는 작업만 하려면 읽기락을 사용해 임계 영역을 보호하고 작업이 완료되면 락을 해제함 =&gt; 읽기 스레드들이 읽기락을 건 임계영역에 여러개 접근이 가능함  읽기락, 쓰기락은 서로 차단하는 것도 가능함만약 어떤 스레드가 쓰기락을 얻으면 해당락이 풀릴때까지 다른 스레드는 읽기 락을 얻을 수 없음. (반대의 상황도 가능함)    public static final int HIGHET_PRICE = 1000;    public static void main(String[] args) throws InterruptedException {        InvertoryDatabase invertoryDatabase = new InvertoryDatabase();        Random random = new Random();        for (int i = 0; i &lt; 100000; i++) {            invertoryDatabase.addItem(random.nextInt(HIGHET_PRICE));        }        Thread writer = new Thread( () -&gt; {           while (true) {               invertoryDatabase.addItem(random.nextInt(HIGHET_PRICE));               invertoryDatabase.removeItem(random.nextInt(HIGHET_PRICE));               try{                   Thread.sleep(10);               }catch (Exception e) {               }           }        });        writer.setDaemon(true);        writer.start();        int nuberTreadTheads = 7;        List&lt;Thread&gt; readers = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; nuberTreadTheads; i++) {            Thread reader = new Thread(() -&gt; {                for (int j = 0; j &lt; 100000; j++) {                    int upperBoundPrice = random.nextInt(HIGHET_PRICE);                    int lowerBoundPrice = upperBoundPrice &gt; 0 ? random.nextInt(upperBoundPrice) : 0;                    invertoryDatabase.getNumberOfItemInPriceRange(lowerBoundPrice, upperBoundPrice);                }            });            //reader.setDaemon(true);            readers.add(reader);        }        long start = System.currentTimeMillis();        for (Thread reader : readers) {            reader.start();        }        for (Thread reader : readers) {            reader.join();        }        long end = System.currentTimeMillis();        System.out.println(end - start);    }    public static class InvertoryDatabase {        // 레드 블랙 트리        private TreeMap&lt;Integer, Integer&gt; priceToCountMap = new TreeMap&lt;&gt;();        // 기존 락        private ReentrantLock lock = new ReentrantLock();        // 읽기 쓰기 락        private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();        // 읽기 락        private Lock readLock = reentrantReadWriteLock.readLock();        // 쓰기 락        private Lock writeLock = reentrantReadWriteLock.writeLock();        public int getNumberOfItemInPriceRange(int loverBound, int upperBound) {            // 읽기부분 락            //lock.lock();            readLock.lock();            try {                Integer fromKey = priceToCountMap.ceilingKey(loverBound);                Integer toKey = priceToCountMap.ceilingKey(upperBound);                if (fromKey == null || toKey == null) {                    return 0;                }                NavigableMap&lt;Integer, Integer&gt; rangeOfPrices =                        priceToCountMap.subMap(fromKey, true, toKey, true);                int sum = 0;                for (int numberOfItemForPrice : rangeOfPrices.values()) {                    sum += numberOfItemForPrice;                }                return sum;            } finally {                //lock.unlock();                readLock.unlock();            }        }        public void addItem(int price) {            // 쓰기부분 락            //lock.lock();            writeLock.lock();            try {                Integer itemForPrice = priceToCountMap.get(price);                if (itemForPrice == null) {                    priceToCountMap.put(price, 1);                } else {                    priceToCountMap.put(price, itemForPrice + 1);                }            } finally {                //lock.unlock();                writeLock.unlock();            }        }        public void removeItem(int price) {            // 쓰기부분 락            //lock.lock();            writeLock.lock();            try {                Integer itemForPrice = priceToCountMap.get(price);                if (itemForPrice == null || itemForPrice == 1) {                    priceToCountMap.remove(price);                } else {                    priceToCountMap.put(price, itemForPrice - 1);                }            } finally {                //lock.unlock();                writeLock.unlock();            }        }    }  기존 락에서는 다수의 Reader스레드가 공유 리소스에 접속하지못했음  읽기쓰기락을 통해 읽기부분의 락을 여러개 얻고 읽음  성능차이는 3~4배차이남 (위 코드기준 - 하드웨어 성능에 따라 다름)  읽기 작업만 실행하지 않는 곳에서는 일반적인 락보다 읽기쓰기 락의 효율성이 더 좋음출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_6",
    "url": "/posts/Java-Thread6/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-07 17:09:22 +0900",
    





    
    "snippet": " 락킹      멀티스레드 애플리케이션을 제작할 때 Fine-Grained(세밀한 락킹), Coarse-Grained(성긴 락킹) 을 선택할 수 있음.        Coarse-Grained          단일 락킹만 신경쓰면 된다      공유 리소스에 액세스할 떄마다 해당 락킹만 사용하면 됨      메서드에 synchronized 키워드로 해결...",
    "content": " 락킹      멀티스레드 애플리케이션을 제작할 때 Fine-Grained(세밀한 락킹), Coarse-Grained(성긴 락킹) 을 선택할 수 있음.        Coarse-Grained          단일 락킹만 신경쓰면 된다      공유 리소스에 액세스할 떄마다 해당 락킹만 사용하면 됨      메서드에 synchronized 키워드로 해결 가능함      =&gt; 전체 리소스를 잠그는것으로 간단하지만 성능이 중요하다면 최적의 방법은 아님 !  Fine-Grained          모든 리소스에 개별 락킹을 생성하는 것과 같음              병렬성은 키우고 경쟁을 낮춤        =&gt; 데드락에 걸릴 문제가 생김               데드락  모두가 움직이려고 하는데, 다른 사람이 움직인다고 기다리느라 나도 못움직이는 현상 (교착현상) =&gt; 뻗는 현상    // 스레드A가 B를 락을 잡고있는와중에    // 스레드B가 A를 락을 잡고있어서 서로 접근을 못하고 대기를 해서 데드락이 걸린 상황    public static void main(String[] args) throws InterruptedException {        Intersection intersection = new Intersection();        Thread trainA = new Thread(new TrainA(intersection));        Thread trainB = new Thread(new TrainB(intersection));        trainA.start();        trainB.start();    }    public static class TrainB implements Runnable {        private Intersection intersection;        private Random random = new Random();        public TrainB(Intersection intersection) {            this.intersection = intersection;        }        @Override        public void run() {            while (true) {                long sleepTime = random.nextInt(5);                try {                    Thread.sleep(sleepTime);                } catch (Exception e){                }                intersection.takeRoadB();            }        }    }    public static class TrainA implements Runnable {        private Intersection intersection;        private Random random = new Random();        public TrainA(Intersection intersection) {            this.intersection = intersection;        }        @Override        public void run() {            while (true) {                long sleepTime = random.nextInt(5);                try {                    Thread.sleep(sleepTime);                } catch (Exception e){                }                intersection.takeRoadA();            }        }    }    public static class Intersection {        private Object roadA = new Object();        private Object roadB = new Object();        public void takeRoadA() {            synchronized (roadA) {                System.out.println(\"RoadA\" + Thread.currentThread().getName());                synchronized (roadB) {                    System.out.println(\"\");                    try {                        Thread.sleep(1);                    } catch (Exception e) {                    }                }            }        }        public void takeRoadB() {            synchronized (roadB) {                System.out.println(\"Road B\" + Thread.currentThread().getName());                synchronized (roadA) {                    try {                        Thread.sleep(1);                    } catch (Exception e){                    }                }            }        }    }해결방안  상호 배제 - 한 번에 한 스레드만 단독으로 리소스에 액세스함  점유와 대기 - 최소 하나의 스레드가 리소스를 점유하며 다른 리소스에 대기  비선점 할당 - 스레드가 사용 완료할 때까지 리소스를 사용할 수 없는 것, 다른 스레드의 리소스를 뺏을 수 없고 다 쓸때까지 기다려야함  순환대기 - 데드락에 빠진 스레드에서 발견할 수 있는데 서로 다른 스레드가 대기함=&gt; 위 네가지 조건이 갖춰지면 데드락이 매우 잘 걸린다그래서 네가지 조건중 하나라도 충족하지않게 만들어주는것으로 해결할 수 있다  마지막 조건인 순환 대기를 예방하는 것으로 동일한 순서로 공유 리소스를 잠그고 모든 코드에 해당 순서를 유지하기    public static void main(String[] args) throws InterruptedException {        Intersection intersection = new Intersection();        Thread trainA = new Thread(new TrainA(intersection));        Thread trainB = new Thread(new TrainB(intersection));        trainA.start();        trainB.start();    }    public static class TrainB implements Runnable {        private Intersection intersection;        private Random random = new Random();        public TrainB(Intersection intersection) {            this.intersection = intersection;        }        @Override        public void run() {            while (true) {                long sleepTime = random.nextInt(5);                try {                    Thread.sleep(sleepTime);                } catch (Exception e){                }                intersection.takeRoadB();            }        }    }    public static class TrainA implements Runnable {        private Intersection intersection;        private Random random = new Random();        public TrainA(Intersection intersection) {            this.intersection = intersection;        }        @Override        public void run() {            while (true) {                long sleepTime = random.nextInt(5);                try {                    Thread.sleep(sleepTime);                } catch (Exception e){                }                intersection.takeRoadA();            }        }    }    public static class Intersection {        private Object roadA = new Object();        private Object roadB = new Object();        public void takeRoadA() {            synchronized (roadA) {                System.out.println(\"RoadA\" + Thread.currentThread().getName());                synchronized (roadB) {                    System.out.println(\"\");                    try {                        Thread.sleep(1);                    } catch (Exception e) {                    }                }            }        }        public void takeRoadB() {            synchronized (roadA) {                System.out.println(\"Road A\" + Thread.currentThread().getName());                synchronized (roadA) {                    try {                        Thread.sleep(1);                    } catch (Exception e){                    }                }            }        }    }  락킹 순서를 통일하는것도 데드락을 예방할 수 있는 방법  프로그램이 단순하고 작을수록 훨씬 용이하고 적합할 수 있음  복잡한 프로그램은 다양한 곳에 락킹이 걸려있고 순서를 유지하는게 어려운 단점이 존재대체방법  데드락을 감시하는 장치를 만들수있음  매우 낮은 레벨에서 주기적으로 특정 레지스터 상태를 체크해서 응답하지 않는 스레드가 있다면 데드락이라 판단하고 재가동함  락킹을 처리하기전에 다른 스레드에 의해 락킹이 처리되었는지 확인해서 스레드가 중단되는걸 막은 try lock이라는 방법이 존재  synchronized는 중단된 스레드를 인터럽트할 수 없고, trylock도 사용할 수 없음 =&gt; 순서를 지키는게 불가능할때 적용출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_5",
    "url": "/posts/Java-Thread5/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-07 17:09:22 +0900",
    





    
    "snippet": "원자적  모든 레퍼런스 할당은 원자적임  long 이나 double 을 제외하고는 모두 원자적임.  예외인 이유는 64비트라서임      64비트 컴퓨터라도 실제로는 CPU가 두 개의 연산을 통해32비트씩 읽어서 완료할 가능성이 높음    =&gt; volatile 키워드를 선언시 앞에 붙여주면 원자적으로 계산이 가능함.    원자적 연산은 멀티스레드...",
    "content": "원자적  모든 레퍼런스 할당은 원자적임  long 이나 double 을 제외하고는 모두 원자적임.  예외인 이유는 64비트라서임      64비트 컴퓨터라도 실제로는 CPU가 두 개의 연산을 통해32비트씩 읽어서 완료할 가능성이 높음    =&gt; volatile 키워드를 선언시 앞에 붙여주면 원자적으로 계산이 가능함.    원자적 연산은 멀티스레드 애플리케이션을 쓰는 이유에해당하는, 많은 작업을 병렬 실행하면서도 정확한 결과값을 도출할 수 있는 고성능 애플리케이션을 구축가능함.public static void main(String[] args) {        Mertics mertics = new Mertics();        BusinessLogic businessLogic1 = new BusinessLogic(mertics);        BusinessLogic businessLogic2 = new BusinessLogic(mertics);        MerticsPrint merticsPrint = new MerticsPrint(mertics);        businessLogic1.start();        businessLogic2.start();        merticsPrint.start();    }    public static class Mertics {        private long count = 0;        private volatile double averge = 0.0;        public synchronized void addSample(long sample) {            double currentSum = averge * count;            count++;            averge = (currentSum + sample) / count;        }        public double getAverge() {            return averge;        }    }    public static class MerticsPrint extends Thread{        private Mertics mertics;        public MerticsPrint(Mertics mertics) {            this.mertics = mertics;        }        @Override        public void run() {            while (true) {                try {                    Thread.sleep(100);                }                catch (Exception e) {                }                                double currentAverage = mertics.getAverge();                System.out.println(\"currentAverage = \" + currentAverage);            }        }    }    public static class BusinessLogic extends Thread {        private Mertics mertics;        private Random random = new Random();        public BusinessLogic(Mertics mertics) {            this.mertics = mertics;        }        @Override        public void run() {            while (true) {                long start = System.currentTimeMillis();                try {                    Thread.sleep(random.nextInt(10));                } catch (Exception e) {                }                long end = System.currentTimeMillis();                mertics.addSample(end - start);            }        }    }  경쟁상태  공유 리소스에 접근하는 여러스레드가 있거나그 중 최소한 한 스레드가 공유 리소스를 수정하는 경우로스레드 스케줄리의 순서나 시점에 따라 결과가 달라지는 상황      공유 리소스에서 비원자적 연산이 실행되는게 문제    우선 경쟁 상태를 파악하고 경쟁 상태가 일어나는 임계영역을 동기화 블록을 넣어 보호해야함 데이터 경쟁    public static void main(String[] args) throws Exception {        SharedClass sharedClass = new SharedClass();        ShardTest shardTest = new ShardTest(sharedClass);        ShardTest2 shardTest2 = new ShardTest2(sharedClass);                shardTest.start();        shardTest2.start();    }    public static class ShardTest2 extends Thread{        private SharedClass sharedClass;        public ShardTest2(SharedClass sharedClass) {            this.sharedClass = sharedClass;        }        @Override        public void run() {            for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {                sharedClass.checkDataRace();            }        }    }    public static class ShardTest extends Thread{        private SharedClass sharedClass;        public ShardTest(SharedClass sharedClass) {            this.sharedClass = sharedClass;        }        @Override        public void run() {            for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {                sharedClass.increment();            }        }    }    public static class SharedClass {        private int x = 0; // volatile으로 해결가능        private int y = 0; // volatile으로 해결가능        public void increment() {            x++;            y++;        }        public void checkDataRace() {            if(y &gt; x) {                System.out.println(\"y &gt; x 상태가 일어났습니다.\");            }        }    }=&gt; 컴파일러와 CPU가 성능 최적화와 하드웨어 활용을 위해 비순차적으로 명령을 처리하는 경우가 있음 (논리를 위반하진않음)      비순차적 명령어 처리가 없다면 프로그램 속도는 매우 느려짐    컴파일러 엔지니어들은 입력코드를 가져와서 재정렬해 CPU의 분기 예측 능력과 백테화 능력을 향상시키고 캐시 라인을 프리페치해서 미리 사용할 수 있도록 하고 다양한 최적화를 함  일부 명령이 사용할 수 없는 하드웨어를 필요로 하면 CPU가 명령을 비순차적으로 하지만 다른 명령은 CPU 주기를 낭비하는 대신에 다른 하드웨어에서 실행될 수 있음// 각각의 윗줄에 종속성이 있어 절대 논리가 위반될 수 없음public void Funct() {    x = 1;    y = x+2;    z = y+10;}/* CPU나 컴파일러 관점에서는 해당 메서드들의 논리가 동일함*/public void Funct1() {    x++;    y++;}public void Funct2() {    y++;    x++;}      Java는 일반적으로 다른 스레드를 통해 동시에 일어나는 연산에 대해서는 시맨틱 이전의 순서는 보장하지 않지만, 예외인 경우가 몇 가지 있습니다.    순서를 지키는 솔루션          synchoronized 키워드를 사용해서 동시 실행에 대응하고 읽기, 쓰기, 공유 변수로부터 보호할 수 있음.                  synchoronized가 선언된 메서드를 재정렬해도 문제가 되지않음하나의 스레드만 접근이 가능하기에 데이터 경쟁은 일어나지않음                    공유 변수에 volatile 키워드를 적기                  잠금 오버헤드를 줄이고 처리 순서를 보장함              volatile int shared;  public void func() {// 모든 명령은 이전에 실행 메모리 장벽Read or Write -&gt; shared 변수// 모든 명령은 이후에 실행 메모리 장벽  }                                            경쟁 상태  데이터 경쟁=&gt; 두 상황 모두 스레드가 공유 리소스를 사용하거나 스레드가 리소스를 수정하는 경우 (원인은 다름)  synchoronized, volatile 키워드로 문제를 해결가능함.  volatile는 변수 타입의 읽기, 쓰기, long + double 타입에 대한 데이터 경쟁을 해결할 수 있음.  volatile는 순서가 보장되기에 모든 경우의 데이터 경쟁을 해결해줌  한 스레드에 의해 수정된 모든 공유 변수는 보호해야함출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "스프링 1 (추가중)",
    "url": "/posts/Spring1/",
    "categories": "개발, 스프링",
    "tags": "spring",
    "date": "2023-12-06 20:00:00 +0900",
    





    
    "snippet": "  - 필자는 진짜 웹이 처음이고, 스프링도 살면서 처음하기에아주 쉬운 내용으로, 경우에 따라 추상적인 내용으로 글을 적을 순 있음.  # 웹이란?- 인터넷 : 전세계의 모든 네트워크를 묶는 연결망- 웹 : 전세계의 인터넷에 어딘가에 있는 특정 공간- HTTP : 인터넷 안에서 웹 공간을 찾아 가기위한 역할   # 백엔드 개발자는?- 백엔드 개발자는 ...",
    "content": "  - 필자는 진짜 웹이 처음이고, 스프링도 살면서 처음하기에아주 쉬운 내용으로, 경우에 따라 추상적인 내용으로 글을 적을 순 있음.  # 웹이란?- 인터넷 : 전세계의 모든 네트워크를 묶는 연결망- 웹 : 전세계의 인터넷에 어딘가에 있는 특정 공간- HTTP : 인터넷 안에서 웹 공간을 찾아 가기위한 역할   # 백엔드 개발자는?- 백엔드 개발자는 API를 개발함.- Application Program Interface- 운영체제와 응용프로그램 사이의 통신에 사용되는 언어나 메시지 형식 (중간역할을 해줌, 점원같은 역할)### REST APIRepresentational State Tranfer의 약자로 웹을 이용할때 제약조건들을 정의하는 소프트웨어 아키텍처 스타일.- 고전API : 화면을 포함해서 규칙이고 뭐고 일단 알아서 데이터를 보내줌. =&gt; 기준, 틀이 없음.- REST API : REST 규칙대로 잘 구현된 API를 REST API라고 부를 수 있고 그 외에는 HTTP API라고 불러야함.규칙을 잘 지킨 API를 RESTful API라고 불림.- 구성요소: URL(자원), Method(행위), Representation(표현)### URL- 웹에서 요청하는 방법 = API를 요청하는 방법으로 볼 수 있음.- 웹사이트에서 주소를 통해 원하는 정보를 요청을 하는 것.(식별자 역할)   # 스프링이란?- 로드 존슨이 2002년에 Expert One-on-One J2EE Design and Development에서 소스코드를 공개하고 개발방법을 제안한게 오픈소스로 계속 진행되었음. ## **현재 start.spring.io에 2버전 지원이 끝남**   ### 스프링 프로젝트 폴더 구조- src폴더에 소스코드가 들어있음- main아래로 그룹과 패키지를 쭉 따라가면 ~~Application클래스가 나오는데 이 파일에 메인메서드가 있음- resources 폴더는 프로그래밍 언어 외적으로 짠 파일들을 나둠- bulid.gradle -&gt; GRADLE이 빌드할때 이 파일에 적힌대로 빌드함- gradlew.bat 그래들을 빌드해서 패키징을 할 때 사용하는 bat파일임. -&gt; 빌드하기 위한 실행용 파일- External Libraries에는 그래들이 다운받은 라이브러리들이 들어있음 ### 스프링 주요 개념- IOC : Inversion of Control (제어의 역전)  - 프로그램의 흐름을 제어하는 주체가 정반대로 뒤집힌다  - 객체의 흐름을 제어하는 주체가 정반대로 뒤집힌다- DI : Dependency Injection (의존성 주입)  - 의존한다 = 사용한다  - 객체를 사용한다 -&gt; 객체의 메서드, 필드를 사용- 컨테이너 (Spring / IOC / **DI**)  - 객체를 생성해서 관리하는 공간  - 빈을 담아두는 곳- 스프링 빈  - 스프링 객체 ### 스프링 MVC- View: 화면- Model: 데이터 처리, 로직  - Service   - Repository - Controller: Model - View 중간 매개체"
  },
  
  {
    "title": "자바 Thread_4",
    "url": "/posts/Java-Thread4/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-05 18:09:22 +0900",
    





    
    "snippet": "스레드 간 데이터 공유public static void main(String[] args) throws InterruptedException {        // 하나의 인스턴스로 아이템 객체를 주입        InvertoryCounter invertoryCounter = new InvertoryCounter();        Incrementin...",
    "content": "스레드 간 데이터 공유public static void main(String[] args) throws InterruptedException {        // 하나의 인스턴스로 아이템 객체를 주입        InvertoryCounter invertoryCounter = new InvertoryCounter();        IncrementingThread incrementingThread = new IncrementingThread(invertoryCounter);        DecrementingThread decrementingThread = new DecrementingThread(invertoryCounter);        /* 아이템을 넣는 스레드가 시작되고 종료후,            아이템을 빼는 스레드가 시작되어 0이 나옴 */        incrementingThread.start();        incrementingThread.join();        decrementingThread.start();        decrementingThread.join();        /* 스레드가 서로 데이터를 공유하고 있기 때문에            실행할때마다 값이 달라짐 */        incrementingThread.start();        decrementingThread.start();        incrementingThread.join();        decrementingThread.join();        System.out.print(\"현재 아이템수: \");        System.out.println(invertoryCounter.getItems());    }    // 아이템을 빼는 스레드    public static class DecrementingThread extends Thread {        private InvertoryCounter invertoryCounter;        public DecrementingThread(InvertoryCounter invertoryCounter) {            this.invertoryCounter = invertoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                invertoryCounter.decrement();            }        }    }    // 아이템을 넣는 스레드    public static class IncrementingThread extends Thread {        private InvertoryCounter invertoryCounter;        public IncrementingThread(InvertoryCounter invertoryCounter) {            this.invertoryCounter = invertoryCounter;        }        @Override        public void run() {            for (int i = 0; i &lt; 10000; i++) {                invertoryCounter.increment();            }        }    }    private static class InvertoryCounter {        private int items = 0;        public void increment() {            items++;        }        public void decrement() {            items--;        }        public int getItems() {            return items;        }    }      한 스레드는 1을 더하는 작업, 다른 하나는 1을 빼는 작업        실행되는 순서는 스케줄링을 하는 방식에 따라 달라지기에 결과값이 항상 바뀜.  대참사가 일어나는 시나리오  currenVal &lt;- item = 0 (In스레드)  newVal &lt;- currenVal + 1 = 1 (In스레드)  currenVal &lt;- item = 0 (De스레드)  newVal &lt;- currenVal + 1 = 1 (De스레드)  Items &lt;- newVal = -1 (De스레드)  Items &lt;- newVal = 1 (In스레드)=&gt; 최종적으로는 Items에 1이 할당되어 De스레드에서 일어난 일이 아무것도 아니게 되는 결과가 발생되었음 ! (5번과 6번이 바뀌어도 대참사)  개선하기 ! 임계영역  멀티 스레드에 의해 동시 실행되지않게 보호해야하는 코드가 있는 영역  Synchronized - monitor          여러 개의 스레드가 코드 블록이나 전체 메서드에 액세스할 수 없도록 설계된 락킹 메커니즘      private static class InvertoryCounter {        private int items = 0;        public synchronized void increment() {            items++;        }        public synchronized void decrement() {            items--;        }        public synchronized int getItems() {            return items;        }    }  하나의 스레드가 접근하면 다른 스레드는 접근자체가 안됨.  인스턴스(객체)를 기준으로 동기화가 걸림=&gt; Thread A가 메서드를 실행하면 다른 메서드는 모두 실행할 수 가 없음.   Synchronized - Lock          코드의 블럭을 정의하고 Synchronized 키워드를 통해 전체 메서드는 동기화하지않고 특정 영역만 액세스함      스레드간 동기화가 필요한 부분을 적게 만들 수 있는 장점이 있음          private static class InvertoryCounter {        private int items = 0;        Object lock = new Object();        public void increment() {            synchronized (this.lock) {                items++;            }        }        public void decrement() {            synchronized (this.lock) {                items--;            }        }        public int getItems() {            synchronized (this.lock) {                return items;            }        }    }  동기화 블록이나 메서드는 Reentrant 즉, 재진입할 수 있는 요소  스레드1이 이미 다른 동기화 메서드나 블록에 있는 상태에서 또 동기화 메서드에 액세스하면 별 문제 없이 그 동기화 메서드에 액세를 할 수 있게됨.  기본적으로는 스레드가 임계영역에 접근하는 것 자체를 막을 순 없음출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_3",
    "url": "/posts/Java-Thread3/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-12-05 10:09:22 +0900",
    





    
    "snippet": "멀티스레딩의 퍼모먼스  레이턴시          시간 단위로 측정되고 작업 하나의 완료 시간으로 정의        처리량          일정 시간 동안 완료한 작업의 양 (시간단위당)        둘은 별개이며, 한쪽이 개선되어도 한쪽에는 영향이 없을수도 영향이 미칠 수도 있습니다.멀티스레드 프로그래밍에서 지연시간을 어떻게 줄이는가?  지연시간 = ...",
    "content": "멀티스레딩의 퍼모먼스  레이턴시          시간 단위로 측정되고 작업 하나의 완료 시간으로 정의        처리량          일정 시간 동안 완료한 작업의 양 (시간단위당)        둘은 별개이며, 한쪽이 개선되어도 한쪽에는 영향이 없을수도 영향이 미칠 수도 있습니다.멀티스레드 프로그래밍에서 지연시간을 어떻게 줄이는가?  지연시간 = T, 작업개수 = N  N으로 지연시간을 줄이는 방법이 있음.          N = 컴퓨터 코어의 개수                  모든 스레드가 인터럽트 없이 하위 작업을 실행해야 최적입니다. =&gt; 모든 스레드가 runable 상태여야함, IO 이나 블로킹 호출도 없어야함.                    시스템에서 CPU를 많이 소모하는 건 실행되고 있지 않아야 한다는것 =&gt; 최적은 안되지만, 어느정도 효율은 가능함.      어떤 작업을 분할로 수행할 수 있는가?  본질적으로 병행 가능하며 하위 작업으로 쉽게 분할가능한 작업  분할이 불가능해 처음부터 끝까지 싱글스레드로 해야하는 작업  부분적으로 하위 작업으로 나누고, 순차적으로 실행해야하는 작업.=&gt; 성능이라는 용어는 다양하게 정의되며, 실제로 측정과 개선에 관심있는 메트릭은 경우에 따라 정의해야함  성능의 두 가지 지표 =&gt; 지연 시간과 처리량  지연시간에 집중해 작업을 여러개로 분할해 지연시간을   줄이는 방법과 이 방식으로 무엇을 할 수 있는지?처리량 - 주어진 기간에 완성되는 작업의 수시간단위, 특히 초 단위로 작업을 나눠 처리량을 측정함처리량 개선방법  Breaking Tasks into Subtasks          작업을 N개의 task로 나누면 T/N으로 가능. =&gt; 최적의 N을 찾을 수 있음.      여러 작업으로 나누고 합치는데에 비용이 드는 단점이 있음        각 작업을 별개 스레드에 스케줄링 하는법          이론적으로 최대 처리량은 N/T                  각 작업을 작은 작업으로 나눌 필요가 없음.          완전 별개의 작업임.                      스레드 풀링          스레드가 샐성되면 풀에 쌓이고 작업이 대기열을 통해 스레드별로 분배됨.      스레드는 이용 가능할 때마다 대기열을 통해 작업을 받음      모든 스레드가 바쁘면 대기열에서 기다림.                  낮은 오버헤드와 효율적인 대기열을 구현가능          자바를 이용한 스레드풀 사용 가능 =&gt; 고정 스레드풀                    출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 3주차 회고",
    "url": "/posts/week3/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-12-03 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 3주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)날이 갑자기 추워져서 컨디션을 제대로 조절하지못해 수업과 공부에 제대로 집중하지못해서 아쉬움이 남은 한 주였다. 그리고 언제나 강사님의 열정은 뛰어나며 교육생들을 위해 많이 알려주실려고 노력한다는걸 느꼈고매니저님이 진짜로 너무 잘 챙겨주셔서 공부에 어떻게든 집...",
    "content": "한화시스템 BEYOND 캠프 3기 3주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)날이 갑자기 추워져서 컨디션을 제대로 조절하지못해 수업과 공부에 제대로 집중하지못해서 아쉬움이 남은 한 주였다. 그리고 언제나 강사님의 열정은 뛰어나며 교육생들을 위해 많이 알려주실려고 노력한다는걸 느꼈고매니저님이 진짜로 너무 잘 챙겨주셔서 공부에 어떻게든 집중하도록 노력했다.2. 좋았던 점 (좋았거나 내가 잘했던 점)Git과 Github에 대해서 강사님이 아주 자세하게 강의를준비해줘서 안쓰던 명령어들을 다시 한 번 써보면서 개념을 다시 정리할 수 있었다.  프로젝트 팀을 진행하면서 팀원들이 모두 열정적이여서 오히려 내가 더 뒤쳐지지않게 노력해야겠다고 느꼈다.3. 아쉬웠던 점일단 컨디션문제로 수업과 프로젝트때 생각한것만큼 집중을 못해서 원하는 결과를 100% 뽑아내진 못했다. (그래도 80%이상 나옴)데이터베이스를 기준으로 생각했어야했는데 나도 모르게 서버에서 함께 처리해야할 것들을 함께 생각하다보니거기서 생각을 정리하느라 시간을 조금씩 허비한것같다.4. 개선할 점분명 하루만에 끝낼거라는 확신을 가지고 진행했는데, 예상밖에 문제들이 있어 끝내지못했다. 당연히 끝낼거라는 너무 안일한 생각때문이 아닌가 싶다. 최대한 시간과 여유를 가지고 작은 프로젝트라도 지금보다 더욱 신경을 써서 하자.5. 다음주 계획1. 자바를 통해 문법과 기능들을 한 번씩 만져보기.2. 자바언어로 자료구조, 알고리즘을 공부하기."
  },
  
  {
    "title": "자바 질문 모음(추가,수정중)",
    "url": "/posts/java_question/",
    "categories": "자바, 질문",
    "tags": "java",
    "date": "2023-11-28 18:30:22 +0900",
    





    
    "snippet": "자바 질문 모음집 (계속 추가, 수정중)1. JVM이 무엇이고, 왜 플랫폼 독립적 언어인가?      JVM 핵심은 컴파일이 된 바이트코드를 실행시켜주고 플랫폼 종속적 -&gt; 이러한 이유로 크로스 플랫폼이 가능.    ## 자바 실행 원리          소스 작성      컴파일      실행      자바 코드로 작성된 .java 파일을 컴퓨터...",
    "content": "자바 질문 모음집 (계속 추가, 수정중)1. JVM이 무엇이고, 왜 플랫폼 독립적 언어인가?      JVM 핵심은 컴파일이 된 바이트코드를 실행시켜주고 플랫폼 종속적 -&gt; 이러한 이유로 크로스 플랫폼이 가능.    ## 자바 실행 원리          소스 작성      컴파일      실행      자바 코드로 작성된 .java 파일을 컴퓨터가 이해할 수 있는 언어로 바꿔야함. -&gt; 이 작업이 컴파일이라고 하고 javac 라는 명령어이다. .class 파일의 바이트코드가 생성되고 플랫폼에 맞춰서 클래스파일을 java라는 명령어로 실행하면 JVM이 플랫폼에 맞춰서 실행한다. JVM은 OS에 종속적이다. (운영체제마다 맞는 JVM 설치해야함)JVM은 바이트코드를 실행시켜 프로그램을 구동하는 역할.개발자는 플랫폼에 상관없이 자바코드를 작성하면 플랫폼에 맞게 설치된 jvm이 알아서 실행시켜주기에 플랫폼 독립적 언어라고 불린다.2. JVM, JRE, JDK 의 차이점?  JVM : 컴파일된 클래스파일을 구동하는 역할 -&gt; 실행자 역할  JRE : 자바 프로그램이 실행될 수 있는 환경          Class Lodaer      Bytecode Verifier      Java Virtual Machine                 컴파일된 클래스된 파일을 메모리에 올려주고 로딩된 클래스된 정보가 플랫폼에 실행되는데 문제가 있는지 없는지를 Bytecode Verifier가 실행되기전 검증함. Bytecode Verifier에 검증된 클래스 파일을 JVM에 최종적으로 실행시켜줌      JVM은 JRE의 한 부분이며, JRE은 클래스파일이 주어지는 동안 자바가 실행을 할 수 있는 환경 제공        JRE : 컴파일된 바이트코드를 실행하는 환경 제공  JDK : 프로그램 개발 이상의 환경 제공          컴파일러 -&gt; javac      데이터베이스      샘플 등 종합 선물세트와 같은 역할      =&gt; JDK는 JRE을 통해 자바가 실행될 수 있는 환경뿐아니라 툴셋까지 제공  자바를 실질적으로 실행시켜주는건 JVM  JVM + Class Loder, Byte Verifier3. 오토박싱과 언박싱이 무엇인가요?  Primitive &amp; Object 타입 두 가지가 있음.  Primitive 가벼운 데이터로 메모리의 스택영역에 저장됨.  Object 데이터는 상대적으로 무거우며, 실제 데이터는 힙영역에 있고 그 데이터를 참조주소만 스택메모리에 존재함.  =&gt; 둘이 서로 호환이 될 수가 없음 !!!  J2SE 5 이후로 오토박싱과 언박싱이라는 개념이 생겨서 서로 직접 호환이 가능하게 됨.          Primitive DataType -&gt; Wrapper Class 오토박싱      Wrapper Class -&gt; Primitive DataType 언박싱      Autoboxing  컴파일러가 Primitive DataType -&gt; Wrapper Class 를 하는 과정    int a = 2017;Interger b = new Interger(a)=&gt;Integer b = a // Autoboxing      Unboxing  컴파일러가 Wrapper Class -&gt; Primitive DataType 변환Interger a = new Interger(2017);int b = a.intValue();=&gt;Interger a = new Interger(2017);int b = a; // Unboxing4. Java 스택, 힙 메모리 구조Stack  Primitive data  ReferenceHeap  Object  가비지 컬렉션을 통해 공간을 확보하게 됨.=&gt; 메모리 관리 측면에서는 힙 영역을 신경써야하고, 만약 가득차면 메모리 에러가 발생하게 됨.5. String 과 StringBuffer 차이점?  결론부터 시작하면 문자열 병합이 자주 일어난다면 메모리 관리가 효율적이기에 StringBuffer를 사용함  String에서 힙에서 올라가면 불변성이 있어서 새로운 값을 가져야한다면 새롭게 객체를 생성함.  StringBuffer 가변성이 있어 기존의 객체를 이용해 값만 변경하기에 메모리측면에서 효율적임.// ImmutableString s1 = \"South Korea\";s1 = s1 + \"Seoul\"; // 이때 새로운 객체를 생성해서 할당함.// mutableStringBuffer s2 = new StringBuffer(\"South Korea\");s2.append(\"Seoul\"); // 기존 객체에 값을 더함.// SynchronizationStringBuffer s2 = new StringBuffer(\"South Korea\");s2.append(\"Seoul\"); // 기존 객체에 값을 더함.// non-SynchronizationStringBuilder s4 = new StringBuilder(\"South Korea\");s4.append(\"Seoul\"); // 기존 객체에 값을 더함.  Synchronization 동기화 지원여부 차이가 있음.동기화는 여러 스레드가 공유할 경우, 키를 가지고 있는 스레드만 건드리고 나머지 스레드는 대기해야기에 무결성을 보장하지만, 속도가 더 느릴 수 밖에 없음.  멀티스레드를 고려하지않는 단순 문자열 병합은 StringBuilder가 더 빠름.6. 자바에서 오버라이딩, 오버로딩에 대해 아는가?오버라이딩  오버로딩7. String을 new()로 생성하는 것과 리터럴로 생성하는 것의 차이점?8. static 키워드는 무엇인가?9. 추상클래스와 인터페이스의 차이?10. 자바 예외 처리란?11. 확인되지 않는 예와 확인된 예외의 차이점?12. 예외처리에서 throw, throws의 차이점?13. 바이트 스트림과 문자 스트림의 차이?14. try 또는 catch 블록에서 System.exit를 호출하면 어떻게 되는가?15. ArrayList 와 LinkedList 차이?16. 반복자와 열거형의 차이점?17. SimpleDateFormat 용도는 무엇이며 이를 표시하는 데 어떻게 사용할 수 있습니까?18. Marker Interface 란?19. 스레드를 생성하는 다양한 방법을 설명합니다. 어느 것이 더 나은가?20. 교착상태란? (멀티쓰레드 상태에서 발생)21. main() 메서드에서 static 수정자를 제거하면 어떻게 되는가?22. PreparedStatement, CallableStatement 설명23. RMI 아키텍쳐의 기본 원리?24. JDBC 연결 단계 설명25. 데이터베이스에서 이미지를 어떻게 저장하고 검색하는가?"
  },
  
  {
    "title": "SW공학_2",
    "url": "/posts/sw2/",
    "categories": "개발, SW공학",
    "tags": "sw",
    "date": "2023-11-28 15:35:22 +0900",
    





    
    "snippet": "asdSW 공학 - GIT🌀Git  분산 버전 관리 시스템으로서, 소스 코드의 변경사항을 추적하는데 사용  로컬 시스템과 원격 시스템을 두어, 로컬에서 작업 후 원격공간과 동기화  주요 명령어에는 add, commit, push, merge, branch, checkout 등  브랜치(branch) 기능을 통해 여러 개발자가 동시에 개발하면서도 충돌 ...",
    "content": "asdSW 공학 - GIT🌀Git  분산 버전 관리 시스템으로서, 소스 코드의 변경사항을 추적하는데 사용  로컬 시스템과 원격 시스템을 두어, 로컬에서 작업 후 원격공간과 동기화  주요 명령어에는 add, commit, push, merge, branch, checkout 등  브랜치(branch) 기능을 통해 여러 개발자가 동시에 개발하면서도 충돌 없이 작업  git은 리눅스 토르발즈에 의해 개발된 이후 오픈소스프로젝트에서 관리🌀Github  Github 소스코드가 온라인에서 관리되고 협업할 수 있는 플랫폼  즉, Github은 Git의 리포지토리를 온라인상에서 관리하기 위한 플랫폼  Github -&gt; 마이크로소프트에서 인수  oauth 토근 + 클론 (private repo)          git clone https://토큰정보:x-oauth-basic@git주소      Git 프로젝트 생성 및 수정절차  신규 프로젝트 생성시          방법1                  git clone 레포주소                      해당 폴더로 이동해서 작업 시작                                          방법2                  로컬 컴퓨터에서부터 이미 개발된 프로젝트가 존재시          git init                          .git 컴파일 생성              .git 폴더가 위치한 곳에서 git config –list를 통해 컨피그 정보 조회                                git remote add origin 레포주소                          origin이란, 깃허브 저장소 주소를 의미(원격저장소)                                git remote set url origin                          url변경후 main에 push하면 main의 커밋 이력과 함께 업로드                                git remote remove origin                      모든 이력 push          git push -all origin                  모든 브렌치의 커밋이력 push                    github 사용자 지정  사용자 지정은 사용자 인증과 상관없이 자유롭게 가능  전역적 선언          git config –global user.name 깃허브아이디      git config –global user.email 깃허브이메일      홈 디렉터리 .gitconfig 저장        지역적 선언          git config –local 으로 선언      .git/config 저장      git 기본 명령어  git status          현재 작업 디텍터리와 스테이징 에어리어 상태를 보여줌        git add          staging area로 업로드      git status로 확인        git commit -m “first commit”          local repo 업로드 및 커밋이력 생성      git commit -m “제목” -m “내용”      git log로 이력 확인      git commit만 치면 메시지 입력모드로 전환되고, 첫줄 제목 + 두번째 줄 부터 내용        git commit -am “메시지”          add와 커밋을 동시에      git pull 과 충돌  수정후 수정사항 업로드          add, commit, push        origin이 수정되어 로컬과의 차이 발생시          origin의 변경사항은 로컬에서는 추적 불가능 -&gt; 소스 컨트롤의 변경사항 인지는 로컬 레포지토리에 대한 변경인지        git pull origin main          origin을 기준으로 로컬을 업데이트      pull은 working 디덱터리까지 반영      별도의 브랜치명 명시 안하면 현재 체크아웃 된 브랜치에서 pull      git pull origin main(브랜치명)      만약 로컬의 변경파일과 origin의 변경파일이 같이 변경되면 충돌발생 가능성      git 취소 상황  특정 스탭까지의 저장 사항을 취소          woring dir 수정사항 취소      add 후 취소      commit 이후 취소      push 후 origin까지 배포된 사항 취소        working dir 의 수정사항 취소          git checkout                  파일 수정사항의 취소                    git clean -fdx                  파일을 신규추가 한 경우의 취소                    git checkout . &amp;&amp; git clean -fdx                  수정 및 추가 모두 취소                    개발IDE 사용시 쉽게 수정사항 취소 가능      add 이후 취소                  text2.txt 신규 생성          git status -&gt; untracked file          git add . -&gt; git status -&gt; Changes to be commited          git add 취소                          git reset 또는 git restore -staged                                commit 이후 취소                          git reset HEAD^                                  unstged 상태로 만듬                                            git reset –soft HEAD~1                                  stged 상태 유지                                                              push 후 origin까지 배포된 사항 취소                          git revert 커밋id              특정 커밋버전을 취소시키는 새로운 commit을 생성 후에 다시 push                                          git diff 와 fetch  git diff          현재 작업 디텍터리와 스테이징 영역 사이의 차이점        git diff commmit1 commmit2          두 커밋간 차이점 비교      commmit1 기준으로 commit2와의 비교시 차이점 출력        git diff main origin/main          로컬 레포지터리의 메인과 오리진 메인과의 비교        git fetch origin main          현재 체크아웃 되어있는 main과 origin main과의 차이가 있을 경우 차이점을 담은 참조데이터 fetch_head라는 곳에 생성      차이점을 참고하여 일단 merge 후에 파일수정하고 다시 push      git stash  작업 중단 변경사항을 임시로 저장하고 나중에 다시 적용할 수 있게 해주는 명령어  git stash init          작업저장 목록        git stash show 인덱스          복사본 내용 조회        git stash pop          작업목록에서 제거하면서 저장사항 적용        git stash apply          작업목록에서 유지하면서 적용      git tag  mian브랜치에서 tag를 붙여 버전을 명시하고, release 할 때 아래와 같이 tag를 붙인뒤 push  release에는 소스코드가 압축파일로 생성  관련 명령어          git tag 버전명      git push origin 버전명      add, commit, push 와는 별도로 진행      feature branch 작업  실제 현업에서 branch1, branch1, dev, main 등 여러 브랜치로 관리          브랜치란 버전과는 다르게 개발의 경로를 의미      일반적으로 production 관련 브랜치는 main, 개발용 브랜치는 dev      나머지는 task별로 기능별로 개별적으로 만들어 사용 -&gt; feature브랜치라 정함      feature 브랜치에서 작업 후 origin/feature로 푸쉬      Pull Request를 통해 dev까지 merge      dev에서 main으로 최종 merge        주요 명령어          git fetch origin                  모든 브랜치 정보 fetch                    git branch                  현재 저장소에 있는 모든 브랜치 목록                    git branch 브랜치명                  브랜치명으로 새로운 브랜치를 생성하는 명령어          기존에 checkout 되어 있는 브랜치를 기준으로                    merge 전략      브랜치에서 dev로 PR을 만든 뒤 merge하는 상황        merge / rebase / squash          merge                  merge 두 브랜치의 변경 사항을 통합하는 기본적인 방법          branch1에서 넘어온 커밋ID와 신규 머지 커밋ID가 dev에 남게 됨                    rebase                  한 브랜치의 커밋을 다른 브랜치의 최신 커밋에 “재적용”하는 방식          이때에는 브랜치에서 넘어온 커밋ID가 아닌, 새로운 커밋ID가 발급되어 dev브랜치 생성          merge 커밋ID 남지 않게 되어, 깔끔한 커밋관리가 되나 이후에 branch1에서 다시 merge를 할 때 충돌이 발생하므로, 사용하던 branch1은 더이상 사용이 어려움.                    squash                  squash는 여러 커밋을 하나의 커밋으로 합치는 과정          local repository에서 여러 커밋을 발생시켰을 때 해당 커밋ID를 통합하여 하나의 커밋ID만들어 dev에는 하나의 커밋ID로만 이력 생성                    rebase, squash는 feachre에서 dev브랜치로 merge할때에는 선택에 따라 가능하나, dev에서 main에 merge할때는 부적절      "
  },
  
  {
    "title": "마크다운 내용 정리글(수정중)",
    "url": "/posts/Markdown/",
    "categories": "개발, 마크다운",
    "tags": "markdown",
    "date": "2023-11-28 10:09:22 +0900",
    





    
    "snippet": "asdasd마크다운 작성을 위한 게시글  제목 HeaderH1은 ===로도 만들 수 있습니다.this h1 ===H2는 —로도 만들 수 있습니다.this h2---제목 1제목 2제목 3제목 4제목 5제목 6  줄바꿈 (Line Breaks) .          띄어쓰기 2번 또는 로 표현 가능 하다.            수평선 (Horizontal R...",
    "content": "asdasd마크다운 작성을 위한 게시글  제목 HeaderH1은 ===로도 만들 수 있습니다.this h1 ===H2는 —로도 만들 수 있습니다.this h2---제목 1제목 2제목 3제목 4제목 5제목 6  줄바꿈 (Line Breaks) .          띄어쓰기 2번 또는 로 표현 가능 하다.            수평선 (Horizontal Rule)        글자 강조 (Emphasis)        인용문 (BlockQuote)        목록 (List)        체크리스트        코드블럭        링크 (Links)        이미지 (Images)        표 (Table)        코드 (Code)        원시 HTML    이모지마크다운 이모지 모음 사이트https://www.webfx.com/tools/emoji-cheat-sheet/출처 https://goddaehee.tistory.com/307 [갓대희의 작은공간:티스토리]https://inpa.tistory.com/entry/MarkDown-📚-마크다운-문법-💯-정리 [Inpa Dev 👨‍💻:티스토리]"
  },
  
  {
    "title": "SW공학_1",
    "url": "/posts/sw/",
    "categories": "개발, SW공학",
    "tags": "sw",
    "date": "2023-11-28 09:09:22 +0900",
    





    
    "snippet": "SW 공학      소프트웨어 공학은 인류의 이익을 위해서 소프트웨어와 관련된 원리, 지식, 도구등을 활용하여 새로운 제품, 도구등을 만드는 것    계획, 요구사항 분석, 설계, 구현, 시험, 및 유지보수과정(폭포수모델)  프로젝트 계획          문제 정의 (무엇을 개발할지)      법적, 경제적, 기술적 타당성 조사      일정 계획  ...",
    "content": "SW 공학      소프트웨어 공학은 인류의 이익을 위해서 소프트웨어와 관련된 원리, 지식, 도구등을 활용하여 새로운 제품, 도구등을 만드는 것    계획, 요구사항 분석, 설계, 구현, 시험, 및 유지보수과정(폭포수모델)  프로젝트 계획          문제 정의 (무엇을 개발할지)      법적, 경제적, 기술적 타당성 조사      일정 계획                  WBS(Work Breakdown Structure) 대표적          작업 분할 구조도          프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화하는 작업          수행사 및 담당자까지 지정                      프로젝트 계획          사용자의 요구사항과 시스템의 기능이 문서화되어야 하는 단계      고객과 개발 회사의 계약서로서의 가치를 가짐        설계          시스템 아키텍쳐 설계      소프트웨어 아키텍쳐 설계      컴포넌트 설계      소프트웨어 아키텍쳐 설계        테스팅          요구사항과 설계에 맞는지 점검 과정으로서 전체 개발 기간의 40% 가까이 차지      테스트 유형                  유닛테스트 -&gt; 프로그램의 기본단위인 모듈에 대한 테스트를 수행하는 단위 시험          통합테스트 -&gt; 단위 시험 후 모듈들을 통합하여 테스트를 수행하는 통합 시험          시스템테스트 -&gt; 통합 시험 이후 소프트웨어와 다른 시스템 요소(하드웨어, 정보 등)들과 통합하여 시스템의 기능을 만족하는지 확인하는 시스템 시험          인수테스트 -&gt; 고객이 참여하여 고객 요구사항 만족 여부를 검증하는 인수 시험                      유지보수          사용중 발생하는 여러 변경사항에 대해 적응하는 활동이며 변화에 따른 프로그램 추가/수정을 하는 과정        폭포수모델 (waterfall)          계획, 요구사항 분석, 설계, 구현(프로그래밍), 시험, 유지보수의 순서로 시스템의 개발되는 전통적인 방법론      개념 정립에서 구현까지 하향식 접근방법을 사용하여 높은 추상화 단계에서 낮은 추상화 단계로 이동하는 모델              폭포수 방법론의 순차적이고 구조화된 접근 방식은 초기 단계에서의 광범위한 계획과 구조화된 개발프로세스가 중요한 대규모 모놀리식 시스템의 개발에 적합            장점                  프로젝트 진행과정을 세분화하기 때문에 큰 프로젝트의 진척과 인력 관리가 용이          개발방법론의 초기 모델로서 많은 수행과 검증을 거쳐왔고, 대규모 시스템 구축에 있어 경험 축적          man/month 기반의 비용산정과 일정산정의 용이함                    단점                  고객이 원하는 요구사항을 초기에 구체화 하기 어려움          오류발견과 수정이 순환적으로 발생하므로, 순차적 개발이 현실적으로 어려움          시스템 구축이 후반부에 가서야 완료되는 경우엔, 시스템 문제점 파악 어려움          설계한 아키텍쳐의 문제가 후반부에 가서야 발견되는ㄴ 경우가 많아, 수정의 어려움          man/month 기반의 비용산정의 불합리성과 일정산정의 부정확함                      애자일모델          기존 방법론은 프로젝트의 본질적인 목표보다 계획 수립, 문서화, 품질 관리 등 추가로 수행되는 작업을 위해 오버헤드비용(부수적인비용)을 과다하게 요구      개발자들이 좋은 것을 빠르고 낭비없이 만들기 위해 경량화된 가벼운 개발방법론이 애자일      애자일 방법론의 문제                  분석, 설계, 구현, 시험이 끊임없이 진행되는 반복되는 순환적 개발과정          각 단계를 짧게 1-2주 짧은 스프린트를 잡고 특정 기능이 동작하는 데모, 즉 최소 기능 제품(Minumum Viable Product)를 통해 배포후에 고객에게 시연하고 피드백을 통해 다시 반복적으로 분석, 설계, 구현, 시험          요구사항의 변화가 자주 일어나거나 개발자가 소규모인 소형 또는 중간 사이즈의 비즈니스 시트템, 게임 소프트웨어 개발이 적합                            애자일 방법론의 작은 단위의 기능개발, 팀별 자율성 등의 특징은 모놀리식 아키텍쳐가 아닌 msa 아키텍쳐와 적합한 구조                스크럼(SCRUM)                  특정 이슈를 bottom up 방식을 통해 발생하여 문제를 공유하고 문제를 짧은 스탭을 통해 해결해 나가는 과정          PO, PM(PL), 기획자, 개발자, 디자이너 등이 스크럼의 참여자          일반적으로 개발팀에서 SCRUM 회의라면 우선순위별로 발생된 이슈에 대해 논의하고, 스프린트 별로 진척 상황을 회고 하는 것          스크럼을 위한 툴로서 아틀라시안의 JIRA를 주로 사용                        지라                  스프린트 생성 -&gt; 스토리 생성 -&gt; 작업 생성등의 분류 과정을 통해 작업 생성                          이때 작업 생성은 실무에서 이슈발행, 티켓발행, 백로그 생성등의 용어로 사용                                만들어진 스프린트가 시작되면 보드에서 시각화되어 보여짐.                          TODO, IN PROGRESS, IN REVIEW, DONE 등의 단계를 거치면서 생명주기 관리                                지라는 Github, Slack 등의 툴과 연계해 유기적으로 활용.                    모놀리식 아키텍쳐  단일 대규모 애플래케이션          애플리케이션의 모든 기능이 하나의 큰 시스템으로 구축되는 방식        통합된 개발 접근          애플리케이션의 모든 구성 요소가 하나의 코드베이스에 통합되어 있으며, 이로 인해 소스코드가 서로 영향을 받고 배포 및 테스트가 복잡하고 어려워짐        관리 및 유지보수의 복잡성          상호 영향도                  하나의 모듈을 수정할 떄, 이를 참조하거나 영향을 받는 모든 모듈들도 영향을 받을 수 밖에 없는 구조                    SW아키텍쳐의 복잡도와 배포의 어려움                  소스코드의 영향도로 인해, 배포도 팀마다 불가능하고 전체배포 시간을 정하여 모든 소스코드를 한꺼번에 반영.          일반적으로 새벽시간이나 DB작업 등 복잡한 작업의 경우엔 새벽에 진행. 심지어 변경의 규모가 큰 작업일 경우 명절 등 공휴일을 정해 배포                    시스템 구성의 복잡성                  시스템이 복잡해 개발의 영향도 파악이 어려움                    MSA 아키텍쳐  모놀리식에서 문제의 원인이었던 서비스들간의 의존성이 약화되거나 제거돼 느슨한 결합상태로 구성  서비스는 저마다 데이터베이스를 가지며, 각 서비스마다 더 적합한 기술이 사용  서비스의 수정이 발생하여도 다른 서비스로의 영향이 없거나 적기 때문에, 독립적인 개발 및 배포가능  장애가 발생하더라도 장애 범위가 서비스에만 국한  특정 이벤트로 대량의 트래픽이 몰릴 경우, 해당 서비스에만 컴퓨팅 리소스를 더 투입하는 스케일 아웃(서버를 늘리기(구조)) 전략을 적용 + (스케일업은 컴퓨터 성능을 올림)      API 기반 통신          소프트웨어나 시스템 간의 상호작용을 가능하게 하는 규약 또는 인터페이스      즉, 소프트웨어 컴포넌트 간의 ‘연결고리’역할을 하며, 사용자들이 복잡한 코드를 직접 작성하지 않고도 특정 기능에 대한 정보를 받거나 구현하는데 도움 -&gt; ex) 한국거래소API 통해 시세 받기 등      API기반 통신은 주로 동기적 처리를 위한 용도            이벤트 기반 통신          비동기 또는 독립적 처리를 위한 용도      주문이 발생하면(신규주문) 주문 정보를 가진 메시지를 발행하고, 재고 서비스나 앱 푸시 서비스에서 해당 메시지를 구독하여 후속 처리            MSA의 컨테이너 환경구성          MSA는 경량화된 아키텍쳐로서 분산 아키텍처로 구성                  경량화된 서버인 도커 컨테이너와 같은 컨테이너 기반 아키텍쳐에 적합          확장가능성에 염두를 둔 msa 설계사상과 확장에 유연하고 용이한 이미지 기반의 컨테이너 서버구성은 상호 적합한 기술 선택지          쿠버네티스와 같은 컨테이너 오케스트레이션 기술 덕분에 대규모 컨테이너 시스템을 기존의 레거시보다 효율적으로 관리할 수 있는점이 큰 강점                            쿠버네티스 활용                  자동화된 배포와 롤아웃 관리를 통해 MSA환경에서의 빈번한 수정과 배포가능          자동 확장과 로드밸런싱                          특정 서비스의 많은 트래픽 상황시 빠른 자동확장 서비스와 로드밸런싱                                서비스 검색과 네트워킹을 통한 내부 통신 용이                          내부 서비스간의 통신 용이와 확장성이 하게 함으로서 MSA컨테이너간의 통신에 최적화                                자원 관리 및 최적화                    "
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 2주차 회고",
    "url": "/posts/week2/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-26 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋...",
    "content": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋았던 점 (좋았거나 내가 잘했던 점)- 5층 도서관?에 원하는 책이 생겨서 바로 빌릴 수 있었다 ㅎ- 매니저님들이 수업과 공부에 집중할 수 있도록 환경을 조성해주는것에이 글을 통해서 큰 감사의 인사를 드립니다.3. 아쉬웠던 점- 시간이 지나감에 따라 다른 기수들도 팀프로젝트를 하러 윗층까지 올라오는데,모임을 하는 장소가 적은거같은 느낌이 들고또한 대형tv가 있는 자리는 정해졌기에 자리경쟁이 치열해질 것으로 보인다.- 강의때 내용을 블로그에 바로 적을려고 했지만, 아직까지 마크다운 사용법이 익숙하지않아서 바로 실행에 옮기지 못했다. 4. 개선할 점- 자바와 웹개발이 처음이다보니 모르는것이 너무나도 많은데목표를 정해 하나씩 달성해나갈 수 있도록 하자 !!!5. 다음주 계획- 마크다운에 대한 블로그 글 업로드!!!"
  },
  
  {
    "title": "자바 Thread_2",
    "url": "/posts/Java-Thread2/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-23 23:09:22 +0900",
    





    
    "snippet": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이...",
    "content": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이션 전체를 중단하기 위해서임 !(최소 하나의 스레드만 실행되고 있어도 프로세스는 종료되지않음)Thread.interrupt()-&gt; 각 스레드는 인터럭트 메서드를 가지고 있음  우리가 인터럽트하려는 스레드가 인터럽트 당했을 때 익셉션을 발생시키는 경우 !  이터럽트하려는 스레드가 신호를 명시적으로 처리하기 위해 !    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.start();        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }    }    private BigInteger pow(BigInteger base, BigInteger power) {        BigInteger result = BigInteger.ONE;        for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {            if(Thread.currentThread().isInterrupted()) {                System.out.println(\"interrupted\");                return BigInteger.ZERO;            }            result = result.multiply(base);        }        return result;    }}Thread Daemon  메인 스레드가 종료되어도 애플리케이션 종료를 막지 않음.  주로 백그라운드 작업 (텍스트앱에서 시간마다 자동저장하는 기능)  작업 스레드에서 실행되는 코드를 제어할 수 없는 경우, Daemon쓰레드가 앱 종료를 방해하는 일은 없어야함.    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.setDaemon(true);        thread.start();        Thread.sleep(100);        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }        private BigInteger pow(BigInteger base, BigInteger power) {            BigInteger result = BigInteger.ONE;            for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {                if(Thread.currentThread().isInterrupted()) {                    System.out.println(\"interrupted\");                    return BigInteger.ZERO;                }                result = result.multiply(base);            }            return result;        }    }Thread join  스레드는 각각 독립적이고 실행순서를 우리가 통제할 수 없다.출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "자바 Thread_1",
    "url": "/posts/Java-Thread/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-20 23:09:22 +0900",
    





    
    "snippet": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/...",
    "content": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/br&gt; &lt;/br&gt;                  컨텍스트 스위치                            동시에 많은 스레드를 다룰 때는 효율성이 떨어지기에 이 개념이 아주 중요함 !      사람으로 생각하면 생각을 가다듬고, 집중력을 회복하는 시간 ! (회사에서 많은 업무를 동시에 못하는것처럼!!)      CPU에서 실행되는 각 스레드는 CPU 안에 레지스터, 캐시, 메모리 내의 커널 리소스 일정 부분을 차지하게됨.다른 쓰레드로 전환할 때는 기존의 모든 데이터를 저장하고, 다른 쓰레드의 리소스를 CPU와 메모리에 복원해야함.            너무 많은 스레드를 사용시 ‘스래싱’이 발행    같은 프로세스에 속한 두 스레드 간의 컨텍스트 스위치(효율) » 다른 프로세스의 두 스레드간의 스위치(비효율)      그럼 언제 컨텍스트 스위치를 할 지 결정하는가??    쓰레드 스케줄          들어온 순서대로 작업을 처리할지?      짧은 시간인것부터 먼저 처리할지?        쓰레드 vs 프로세스          멀티 스레드와 멀티 프로세스.      스레드는 많은 리소스를 공유하니 같은 프로세스 안에서 스레드를 사용하는 것이 좋음.      보안,안정성 -&gt; 멀티 스레드는 스레드 하나에 프로세스가 다운될 가능성도 있음.      자바 스레드의 기능과 디버깅 방법        // 스레드 생성        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                System.out.println(\"now thread: \" + Thread.currentThread().getName());                System.out.println(\"current thread: \" + Thread.currentThread().getPriority());                /* 에러 반환 */                throw new RuntimeException(\"Exception\");            }        });        // 스레드에 문제를 생겼을때 해당 헨들러가 작동해서 에러를 반환        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                System.out.println(\"error happy\");            }        });&lt;/br&gt;자바 스레드 상속 예제public static final int MAX_PASSWORD = 9999;    public static void main(String[] args) throws InterruptedException {        Random random = new Random();        Vault vault = new Vault(random.nextInt(MAX_PASSWORD));        // 모든 클래스가 Thread클래스를 상속받았기에 제네릭으로 사용 가능함.        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();        threads.add(new AscendingHackerThread(vault));        threads.add(new DescendingHackerThread(vault));        threads.add(new PoliceThread());        // 쓰레드 담긴 개수만큼 반복해서 실행        for (Thread thread : threads) {            thread.start();        }    }    // 해당 방법처럼 클래스에 쓰레드를 상속받아서 쓰레드클래스로 사용 가능    private static class NewThread extends Thread {        @Override        public void run(){            System.out.println(\"Hello\" + this.getName());        }    }    private static class Vault {        private int passward;        public Vault(int passward) {            this.passward = passward;        }        public boolean isCorrentPassword(int guess) {            try {                Thread.sleep(5);            } catch (Exception e){            }            return this.passward == guess;        }    }    // 쓰레드를 상속받은 클래스를 추상클래스로 만들어 활용    private static abstract class HackerThread extends Thread {        protected Vault vault;        public HackerThread(Vault vault) {            this.vault = vault;            this.setName(this.getClass().getSimpleName());            this.setPriority(Thread.MAX_PRIORITY);        }        @Override        public void start() {            System.out.println(\"string thread: \" + this.getName());            super.start();        }    }    private static class AscendingHackerThread extends HackerThread {        public AscendingHackerThread(Vault vault) {            super(vault);        }        @Override        public void run() {            for (int i = 0; i &lt; MAX_PASSWORD; i++) {                if(vault.isCorrentPassword(i)){                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class DescendingHackerThread extends HackerThread {        public DescendingHackerThread(Vault vault){            super(vault);        }        @Override        public void run() {            for (int i = MAX_PASSWORD; i &gt;= 0; i--) {                if (vault.isCorrentPassword(i)) {                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class PoliceThread extends Thread {        @Override        public void run() {            for (int i = 10; i &gt; 0; i--) {                try {                    Thread.sleep(1000);                }catch (Exception e) {                }                System.out.println(i);            }            System.out.println(\"Over Hacker\");            System.exit(0);        }    }핵심 !!!!      애플리케이션에서 여러 개의 스레드를 사용하는 이유는 무엇일까요?  =&gt; 여러 개의 스레드를 사용하면 동시에 여러 개의 관련 작업을 실행할 수 있어서, 애플리케이션의 반응성을 향상시킬 수 있기 때문입니다. 또한 여러 개의 작업을 동시에 실행하여 더 뛰어난 성능을 달성할 수도 있습니다.        하나의 프로세스에 속한 스레드가 공유하는 것은?  =&gt; 힙, 코드, 프로세스의 열린 파일, 프로세스의 메타 데이터        OS는 어떤 방식으로 스케줄링할 스레드를 설계하는가?  =&gt; 각 스레드에 대한 동적 우선 순위를 유지해 인터랙티브 스레드를 우선시하고 시스템의 특정 스레드가 기아 상태가 되는 것을 방지하는것이 모든 OS의 목표 (스케줄링 스레드에 대한 알고리즘은 OS마다 다름)  출처 - https://kmooc.udemy.com/course/java-multi-threading/ (Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기)"
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 1주차 회고",
    "url": "/posts/week1/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-19 12:00:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장...",
    "content": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장 경험이 있었다는 점.  국비는 강사의 역량이 절반이상이라도 들었는데, 적어도 인터넷에서 본 이상한 강사님이 아니라서 좋았다.  - 커리큘럼을 봤을때 생각보다 탄탄했다. (CI/CD까지 하는 곳은 잘 못본거같은데, 거기다가 Action!!)  - 생각보다 건물 안이 깨끗했고 원두커피를 아침, 점심, 저녁마다 먹을 수 있었다 !- 매니저님들이 생각 이상으로 신경을 잘 써주시고, 최대한 도와주시려고 함. 3. 아쉬웠던 점- 일단 화장실이 너무 작았다. 갈때마다 기다리는게 쉽지 않다.  - 수업을 듣는 교육실이 생각보다 작았고, 듀얼모니터 지원X (너무 좋은 환경의 이야기만 들은것일 순 있음)- 커리큘럼의 내용이 탄탄한만큼 시간안에 끝낼 수 있는지 강사님이 먼저 걱정된다;;;  - 내용을 제로베이스에서 시작 + 짧은시간 + 많은 내용을 하다보니 토익700점반처럼 내용을 공식처럼 외우는 느낌이였음. 4. 개선할 점- 앞으로는 강사님 수업내용을 블로그에 바로 정리해서 올릴 수 있도록 하기 !5. 다음주 계획- 블로그를 빠르게 적기위해, 마크다운을 익숙해지도록 하기- 자바 공부 및 정리."
  },
  
  {
    "title": "첫 블로그 글, 소개",
    "url": "/posts/intro/",
    "categories": "일상, 소개",
    "tags": "introduce",
    "date": "2023-11-17 23:09:22 +0900",
    





    
    "snippet": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 ...",
    "content": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 대해 필요한 부분들 정리    추후 꾸준하게 해당글을 수정하도록 약속함."
  }
  
]

