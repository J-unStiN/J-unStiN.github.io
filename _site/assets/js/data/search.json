[
  
  {
    "title": "자바 질문 모음",
    "url": "/posts/java_question/",
    "categories": "자바, 질문",
    "tags": "java",
    "date": "2023-11-28 18:30:22 +0900",
    





    
    "snippet": "자바 질문 모음집 (계속 추가, 수정중)1. JVM이 무엇이고, 왜 플랫폼 독립적 언어인가?      JVM 핵심은 컴파일이 된 바이트코드를 실행시켜주고 플랫폼 종속적 -&gt; 이러한 이유로 크로스 플랫폼이 가능.    ## 자바 실행 원리          소스 작성      컴파일      실행      자바 코드로 작성된 .java 파일을 컴퓨터...",
    "content": "자바 질문 모음집 (계속 추가, 수정중)1. JVM이 무엇이고, 왜 플랫폼 독립적 언어인가?      JVM 핵심은 컴파일이 된 바이트코드를 실행시켜주고 플랫폼 종속적 -&gt; 이러한 이유로 크로스 플랫폼이 가능.    ## 자바 실행 원리          소스 작성      컴파일      실행      자바 코드로 작성된 .java 파일을 컴퓨터가 이해할 수 있는 언어로 바꿔야함. -&gt; 이 작업이 컴파일이라고 하고 javac 라는 명령어이다. .class 파일의 바이트코드가 생성되고 플랫폼에 맞춰서 클래스파일을 java라는 명령어로 실행하면 JVM이 플랫폼에 맞춰서 실행한다. JVM은 OS에 종속적이다. (운영체제마다 맞는 JVM 설치해야함)JVM은 바이트코드를 실행시켜 프로그램을 구동하는 역할.개발자는 플랫폼에 상관없이 자바코드를 작성하면 플랫폼에 맞게 설치된 jvm이 알아서 실행시켜주기에 플랫폼 독립적 언어라고 불린다.2. JVM, JRE, JDK 의 차이점?  JVM : 컴파일된 클래스파일을 구동하는 역할 -&gt; 실행자 역할  JRE : 자바 프로그램이 실행될 수 있는 환경          Class Lodaer      Bytecode Verifier      Java Virtual Machine                 컴파일된 클래스된 파일을 메모리에 올려주고 로딩된 클래스된 정보가 플랫폼에 실행되는데 문제가 있는지 없는지를 Bytecode Verifier가 실행되기전 검증함. Bytecode Verifier에 검증된 클래스 파일을 JVM에 최종적으로 실행시켜줌      jvm은 jre의 한 부분이며, jre은 클래스파일이 주어지는 동안 자바가 실행을 할 수 있는 환경 제공        JRE : 컴파일된 바이트코드를 실행하는 환경 제공  JDK : 프로그램 개발 이상의 환경 제공          컴파일러 -&gt; javac      데이터베이스      샘플 등 종합 선물세트와 같은 역할      =&gt; JDK는 JRE을 통해 자바가 실행될 수 있는 환경뿐아니라 툴셋까지 제공  자바를 실질적으로 실행시켜주는건 JVM  JVM + Class Loder, Byte Verifier3. 오토박싱과 언박싱이 무엇인가요?  Primitive &amp; Object 타입 두 가지가 있음.  Primitive 가벼운 데이터로 메모리의 스택영역에 저장됨.  Object 데이터는 상대적으로 무거우며, 실제 데이터는 힙영역에 있고 그 데이터를 참조주소만 스택메모리에 존재함.  =&gt; 둘이 서로 호환이 될 수가 없음 !!!  J2SE 5 이후로 오토박싱과 언박싱이라는 개념이 생겨서 서로 직접 호환이 가능하게 됨.          Primitive DataType -&gt; Wrapper Class 오토박싱      Wrapper Class -&gt; Primitive DataType 언박싱      Autoboxing  컴파일러가 Primitive DataType -&gt; Wrapper Class 를 하는 과정    int a = 2017;Interger b = new Interger(a)=&gt;Integer b = a // Autoboxing      Unboxing  컴파일러가 Wrapper Class -&gt; Primitive DataType 변환Interger a = new Interger(2017);int b = a.intValue();=&gt;Interger a = new Interger(2017);int b = a; // Unboxing4. Java 스택, 힙 메모리 구조Stack  Primitive data  ReferenceHeap  Object  가비지 컬렉션을 통해 공간을 확보하게 됨.=&gt; 메모리 관리 측면에서는 힙 영역을 신경써야하고, 만약 가득차면 메모리 에러가 발생하게 됨.5. String 과 StringBuffer 차이점?  결론부터 시작하면 문자열 병합이 자주 일어난다면 메모리 관리가 효율적이기에 StringBuffer를 사용함  String에서 힙에서 올라가면 불변성이 있어서 새로운 값을 가져야한다면 새롭게 객체를 생성함.  StringBuffer 가변성이 있어 기존의 객체를 이용해 값만 변경하기에 메모리측면에서 효율적임.// ImmutableString s1 = \"South Korea\";s1 = s1 + \"Seoul\"; // 이때 새로운 객체를 생성해서 할당함.// mutableStringBuffer s2 = new StringBuffer(\"South Korea\");s2.append(\"Seoul\"); // 기존 객체에 값을 더함.// SynchronizationStringBuffer s2 = new StringBuffer(\"South Korea\");s2.append(\"Seoul\"); // 기존 객체에 값을 더함.// non-SynchronizationStringBuilder s4 = new StringBuilder(\"South Korea\");s4.append(\"Seoul\"); // 기존 객체에 값을 더함.  Synchronization 동기화 지원여부 차이가 있음.동기화는 여러 스레드가 공유할 경우, 키를 가지고 있는 스레드만 건드리고 나머지 스레드는 대기해야기에 무결성을 보장하지만, 속도가 더 느릴 수 밖에 없음.  멀티스레드를 고려하지않는 단순 문자열 병합은 StringBuilder가 더 빠름.6. 자바에서 오버라이딩, 오버로딩에 대해 아는가?오버라이딩  오버로딩7. String을 new()로 생성하는 것과 리터럴로 생성하는 것의 차이점?8. static 키워드는 무엇인가?9. 추상클래스와 인터페이스의 차이?10. 자바 예외 처리란?11. 확인되지 않는 예와 확인된 예외의 차이점?12. 예외처리에서 throw, throws의 차이점?13. 바이트 스트림과 문자 스트림의 차이?14. try 또는 catch 블록에서 System.exit를 호출하면 어떻게 되는가?15. ArrayList 와 LinkedList 차이?16. 반복자와 열거형의 차이점?17. SimpleDateFormat 용도는 무엇이며 이를 표시하는 데 어떻게 사용할 수 있습니까?18. Marker Interface 란?19. 스레드를 생성하는 다양한 방법을 설명합니다. 어느 것이 더 나은가?20. 교착상태란? (멀티쓰레드 상태에서 발생)21. main() 메서드에서 static 수정자를 제거하면 어떻게 되는가?22. PreparedStatement, CallableStatement 설명23. RMI 아키텍쳐의 기본 원리?24. JDBC 연결 단계 설명25. 데이터베이스에서 이미지를 어떻게 저장하고 검색하는가?"
  },
  
  {
    "title": "SW공학",
    "url": "/posts/sw2/",
    "categories": "개발, SW공학",
    "tags": "sw",
    "date": "2023-11-28 15:35:22 +0900",
    





    
    "snippet": "SW 공학 - GIT🌀Git  분산 버전 관리 시스템으로서, 소스 코드의 변경사항을 추적하는데 사용  로컬 시스템과 원격 시스템을 두어, 로컬에서 작업 후 원격공간과 동기화  주요 명령어에는 add, commit, push, merge, branch, checkout 등  브랜치(branch) 기능을 통해 여러 개발자가 동시에 개발하면서도 충돌 없이 ...",
    "content": "SW 공학 - GIT🌀Git  분산 버전 관리 시스템으로서, 소스 코드의 변경사항을 추적하는데 사용  로컬 시스템과 원격 시스템을 두어, 로컬에서 작업 후 원격공간과 동기화  주요 명령어에는 add, commit, push, merge, branch, checkout 등  브랜치(branch) 기능을 통해 여러 개발자가 동시에 개발하면서도 충돌 없이 작업  git은 리눅스 토르발즈에 의해 개발된 이후 오픈소스프로젝트에서 관리🌀Github  Github 소스코드가 온라인에서 관리되고 협업할 수 있는 플랫폼  즉, Github은 Git의 리포지토리를 온라인상에서 관리하기 위한 플랫폼  Github -&gt; 마이크로소프트에서 인수"
  },
  
  {
    "title": "마크다운 내용 정리글",
    "url": "/posts/Markdown/",
    "categories": "개발, 마크다운",
    "tags": "markdown",
    "date": "2023-11-28 10:09:22 +0900",
    





    
    "snippet": "asdasd마크다운 작성을 위한 게시글  제목 HeaderH1은 ===로도 만들 수 있습니다.this h1 ===H2는 —로도 만들 수 있습니다.this h2---제목 1제목 2제목 3제목 4제목 5제목 6  줄바꿈 (Line Breaks) .          띄어쓰기 2번 또는 로 표현 가능 하다.            수평선 (Horizontal R...",
    "content": "asdasd마크다운 작성을 위한 게시글  제목 HeaderH1은 ===로도 만들 수 있습니다.this h1 ===H2는 —로도 만들 수 있습니다.this h2---제목 1제목 2제목 3제목 4제목 5제목 6  줄바꿈 (Line Breaks) .          띄어쓰기 2번 또는 로 표현 가능 하다.            수평선 (Horizontal Rule)        글자 강조 (Emphasis)        인용문 (BlockQuote)        목록 (List)        체크리스트        코드블럭        링크 (Links)        이미지 (Images)        표 (Table)        코드 (Code)        원시 HTML    이모지마크다운 이모지 모음 사이트https://www.webfx.com/tools/emoji-cheat-sheet/출처 https://goddaehee.tistory.com/307 [갓대희의 작은공간:티스토리]https://inpa.tistory.com/entry/MarkDown-📚-마크다운-문법-💯-정리 [Inpa Dev 👨‍💻:티스토리]"
  },
  
  {
    "title": "SW공학",
    "url": "/posts/sw/",
    "categories": "개발, SW공학",
    "tags": "sw",
    "date": "2023-11-28 09:09:22 +0900",
    





    
    "snippet": "SW 공학      소프트웨어 공학은 인류의 이익을 위해서 소프트웨어와 관련된 원리, 지식, 도구등을 활용하여 새로운 제품, 도구등을 만드는 것    계획, 요구사항 분석, 설계, 구현, 시험, 및 유지보수과정(폭포수모델)  프로젝트 계획          문제 정의 (무엇을 개발할지)      법적, 경제적, 기술적 타당성 조사      일정 계획  ...",
    "content": "SW 공학      소프트웨어 공학은 인류의 이익을 위해서 소프트웨어와 관련된 원리, 지식, 도구등을 활용하여 새로운 제품, 도구등을 만드는 것    계획, 요구사항 분석, 설계, 구현, 시험, 및 유지보수과정(폭포수모델)  프로젝트 계획          문제 정의 (무엇을 개발할지)      법적, 경제적, 기술적 타당성 조사      일정 계획                  WBS(Work Breakdown Structure) 대표적          작업 분할 구조도          프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화하는 작업          수행사 및 담당자까지 지정                      프로젝트 계획          사용자의 요구사항과 시스템의 기능이 문서화되어야 하는 단계      고객과 개발 회사의 계약서로서의 가치를 가짐        설계          시스템 아키텍쳐 설계      소프트웨어 아키텍쳐 설계      컴포넌트 설계      소프트웨어 아키텍쳐 설계        테스팅          요구사항과 설계에 맞는지 점검 과정으로서 전체 개발 기간의 40% 가까이 차지      테스트 유형                  유닛테스트 -&gt; 프로그램의 기본단위인 모듈에 대한 테스트를 수행하는 단위 시험          통합테스트 -&gt; 단위 시험 후 모듈들을 통합하여 테스트를 수행하는 통합 시험          시스템테스트 -&gt; 통합 시험 이후 소프트웨어와 다른 시스템 요소(하드웨어, 정보 등)들과 통합하여 시스템의 기능을 만족하는지 확인하는 시스템 시험          인수테스트 -&gt; 고객이 참여하여 고객 요구사항 만족 여부를 검증하는 인수 시험                      유지보수          사용중 발생하는 여러 변경사항에 대해 적응하는 활동이며 변화에 따른 프로그램 추가/수정을 하는 과정        폭포수모델 (waterfall)          계획, 요구사항 분석, 설계, 구현(프로그래밍), 시험, 유지보수의 순서로 시스템의 개발되는 전통적인 방법론      개념 정립에서 구현까지 하향식 접근방법을 사용하여 높은 추상화 단계에서 낮은 추상화 단계로 이동하는 모델              폭포수 방법론의 순차적이고 구조화된 접근 방식은 초기 단계에서의 광범위한 계획과 구조화된 개발프로세스가 중요한 대규모 모놀리식 시스템의 개발에 적합            장점                  프로젝트 진행과정을 세분화하기 때문에 큰 프로젝트의 진척과 인력 관리가 용이          개발방법론의 초기 모델로서 많은 수행과 검증을 거쳐왔고, 대규모 시스템 구축에 있어 경험 축적          man/month 기반의 비용산정과 일정산정의 용이함                    단점                  고객이 원하는 요구사항을 초기에 구체화 하기 어려움          오류발견과 수정이 순환적으로 발생하므로, 순차적 개발이 현실적으로 어려움          시스템 구축이 후반부에 가서야 완료되는 경우엔, 시스템 문제점 파악 어려움          설계한 아키텍쳐의 문제가 후반부에 가서야 발견되는ㄴ 경우가 많아, 수정의 어려움          man/month 기반의 비용산정의 불합리성과 일정산정의 부정확함                      애자일모델          기존 방법론은 프로젝트의 본질적인 목표보다 계획 수립, 문서화, 품질 관리 등 추가로 수행되는 작업을 위해 오버헤드비용(부수적인비용)을 과다하게 요구      개발자들이 좋은 것을 빠르고 낭비없이 만들기 위해 경량화된 가벼운 개발방법론이 애자일      애자일 방법론의 문제                  분석, 설계, 구현, 시험이 끊임없이 진행되는 반복되는 순환적 개발과정          각 단계를 짧게 1-2주 짧은 스프린트를 잡고 특정 기능이 동작하는 데모, 즉 최소 기능 제품(Minumum Viable Product)를 통해 배포후에 고객에게 시연하고 피드백을 통해 다시 반복적으로 분석, 설계, 구현, 시험          요구사항의 변화가 자주 일어나거나 개발자가 소규모인 소형 또는 중간 사이즈의 비즈니스 시트템, 게임 소프트웨어 개발이 적합                            애자일 방법론의 작은 단위의 기능개발, 팀별 자율성 등의 특징은 모놀리식 아키텍쳐가 아닌 msa 아키텍쳐와 적합한 구조                스크럼(SCRUM)                  특정 이슈를 bottom up 방식을 통해 발생하여 문제를 공유하고 문제를 짧은 스탭을 통해 해결해 나가는 과정          PO, PM(PL), 기획자, 개발자, 디자이너 등이 스크럼의 참여자          일반적으로 개발팀에서 SCRUM 회의라면 우선순위별로 발생된 이슈에 대해 논의하고, 스프린트 별로 진척 상황을 회고 하는 것          스크럼을 위한 툴로서 아틀라시안의 JIRA를 주로 사용                        지라                  스프린트 생성 -&gt; 스토리 생성 -&gt; 작업 생성등의 분류 과정을 통해 작업 생성                          이때 작업 생성은 실무에서 이슈발행, 티켓발행, 백로그 생성등의 용어로 사용                                만들어진 스프린트가 시작되면 보드에서 시각화되어 보여짐.                          TODO, IN PROGRESS, IN REVIEW, DONE 등의 단계를 거치면서 생명주기 관리                                지라는 Github, Slack 등의 툴과 연계해 유기적으로 활용.                    모놀리식 아키텍쳐  단일 대규모 애플래케이션          애플리케이션의 모든 기능이 하나의 큰 시스템으로 구축되는 방식        통합된 개발 접근          애플리케이션의 모든 구성 요소가 하나의 코드베이스에 통합되어 있으며, 이로 인해 소스코드가 서로 영향을 받고 배포 및 테스트가 복잡하고 어려워짐        관리 및 유지보수의 복잡성          상호 영향도                  하나의 모듈을 수정할 떄, 이를 참조하거나 영향을 받는 모든 모듈들도 영향을 받을 수 밖에 없는 구조                    SW아키텍쳐의 복잡도와 배포의 어려움                  소스코드의 영향도로 인해, 배포도 팀마다 불가능하고 전체배포 시간을 정하여 모든 소스코드를 한꺼번에 반영.          일반적으로 새벽시간이나 DB작업 등 복잡한 작업의 경우엔 새벽에 진행. 심지어 변경의 규모가 큰 작업일 경우 명절 등 공휴일을 정해 배포                    시스템 구성의 복잡성                  시스템이 복잡해 개발의 영향도 파악이 어려움                    MSA 아키텍쳐  모놀리식에서 문제의 원인이었던 서비스들간의 의존성이 약화되거나 제거돼 느슨한 결합상태로 구성  서비스는 저마다 데이터베이스를 가지며, 각 서비스마다 더 적합한 기술이 사용  서비스의 수정이 발생하여도 다른 서비스로의 영향이 없거나 적기 때문에, 독립적인 개발 및 배포가능  장애가 발생하더라도 장애 범위가 서비스에만 국한  특정 이벤트로 대량의 트래픽이 몰릴 경우, 해당 서비스에만 컴퓨팅 리소스를 더 투입하는 스케일 아웃(서버를 늘리기(구조)) 전략을 적용 + (스케일업은 컴퓨터 성능을 올림)      API 기반 통신          소프트웨어나 시스템 간의 상호작용을 가능하게 하는 규약 또는 인터페이스      즉, 소프트웨어 컴포넌트 간의 ‘연결고리’역할을 하며, 사용자들이 복잡한 코드를 직접 작성하지 않고도 특정 기능에 대한 정보를 받거나 구현하는데 도움 -&gt; ex) 한국거래소API 통해 시세 받기 등      API기반 통신은 주로 동기적 처리를 위한 용도            이벤트 기반 통신          비동기 또는 독립적 처리를 위한 용도      주문이 발생하면(신규주문) 주문 정보를 가진 메시지를 발행하고, 재고 서비스나 앱 푸시 서비스에서 해당 메시지를 구독하여 후속 처리            MSA의 컨테이너 환경구성          MSA는 경량화된 아키텍쳐로서 분산 아키텍처로 구성                  경량화된 서버인 도커 컨테이너와 같은 컨테이너 기반 아키텍쳐에 적합          확장가능성에 염두를 둔 msa 설계사상과 확장에 유연하고 용이한 이미지 기반의 컨테이너 서버구성은 상호 적합한 기술 선택지          쿠버네티스와 같은 컨테이너 오케스트레이션 기술 덕분에 대규모 컨테이너 시스템을 기존의 레거시보다 효율적으로 관리할 수 있는점이 큰 강점                            쿠버네티스 활용                  자동화된 배포와 롤아웃 관리를 통해 MSA환경에서의 빈번한 수정과 배포가능          자동 확장과 로드밸런싱                          특정 서비스의 많은 트래픽 상황시 빠른 자동확장 서비스와 로드밸런싱                                서비스 검색과 네트워킹을 통한 내부 통신 용이                          내부 서비스간의 통신 용이와 확장성이 하게 함으로서 MSA컨테이너간의 통신에 최적화                                자원 관리 및 최적화                    "
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 2주차 회고",
    "url": "/posts/week2/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-26 23:37:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋...",
    "content": "한화시스템 BEYOND 캠프 3기 2주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 데이터베이스 설계 프로젝트를 위해 팀구성 + 자리 재배치가 이루어졌음.팀프로젝트는 학교 졸업이후로는 처음하는거라서 적응하는데 시간이 걸릴거같다...해당 팀이 끝까지 갈 지는 잘 모르겠지만,최선을 다해 원하는 결과를 얻을 수 있도록 최선을 다하자 !!2. 좋았던 점 (좋았거나 내가 잘했던 점)- 5층 도서관?에 원하는 책이 생겨서 바로 빌릴 수 있었다 ㅎ- 매니저님들이 수업과 공부에 집중할 수 있도록 환경을 조성해주는것에이 글을 통해서 큰 감사의 인사를 드립니다.3. 아쉬웠던 점- 시간이 지나감에 따라 다른 기수들도 팀프로젝트를 하러 윗층까지 올라오는데,모임을 하는 장소가 적은거같은 느낌이 들고또한 대형tv가 있는 자리는 정해졌기에 자리경쟁이 치열해질 것으로 보인다.- 강의때 내용을 블로그에 바로 적을려고 했지만, 아직까지 마크다운 사용법이 익숙하지않아서 바로 실행에 옮기지 못했다. 4. 개선할 점- 자바와 웹개발이 처음이다보니 모르는것이 너무나도 많은데목표를 정해 하나씩 달성해나갈 수 있도록 하자 !!!5. 다음주 계획- 마크다운에 대한 블로그 글 업로드!!!"
  },
  
  {
    "title": "자바 Thread_2",
    "url": "/posts/Java-Thread2/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-23 23:09:22 +0900",
    





    
    "snippet": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이...",
    "content": "왜, 언제 스레드를 멈춰야 하는가??  스레드는 아무것도 하지 않을때에도 리소스를 사용함.          메모리와 커널 리소스      CPU 시간뿐아니라 캐시까지 사용         생성한 스레드가 이미 작업을 완료했으면, 사용하지 않는 스레드의 리소스를 정리해야함.  스레드가 오작동을 해야하면 중지해야함 ! (응답없는데 서버에 요청)  애플리케이션 전체를 중단하기 위해서임 !(최소 하나의 스레드만 실행되고 있어도 프로세스는 종료되지않음)Thread.interrupt()-&gt; 각 스레드는 인터럭트 메서드를 가지고 있음  우리가 인터럽트하려는 스레드가 인터럽트 당했을 때 익셉션을 발생시키는 경우 !  이터럽트하려는 스레드가 신호를 명시적으로 처리하기 위해 !    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.start();        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }    }    private BigInteger pow(BigInteger base, BigInteger power) {        BigInteger result = BigInteger.ONE;        for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {            if(Thread.currentThread().isInterrupted()) {                System.out.println(\"interrupted\");                return BigInteger.ZERO;            }            result = result.multiply(base);        }        return result;    }}Thread Daemon  메인 스레드가 종료되어도 애플리케이션 종료를 막지 않음.  주로 백그라운드 작업 (텍스트앱에서 시간마다 자동저장하는 기능)  작업 스레드에서 실행되는 코드를 제어할 수 없는 경우, Daemon쓰레드가 앱 종료를 방해하는 일은 없어야함.    public static void main(String[] args) throws InterruptedException {        Thread thread = new Thread(new LongComuptionTask(new BigInteger(\"2\"), new BigInteger(\"10\")));        thread.setDaemon(true);        thread.start();        Thread.sleep(100);        thread.interrupt();    }    private static class LongComuptionTask implements Runnable {        private BigInteger base;        private BigInteger power;        public LongComuptionTask(BigInteger base, BigInteger power) {            this.base = base;            this.power = power;        }        @Override        public void run() {            System.out.println(pow(base, power));        }        private BigInteger pow(BigInteger base, BigInteger power) {            BigInteger result = BigInteger.ONE;            for(BigInteger i = BigInteger.ONE; i.compareTo(power) != 0; i.add(BigInteger.ONE)) {                if(Thread.currentThread().isInterrupted()) {                    System.out.println(\"interrupted\");                    return BigInteger.ZERO;                }                result = result.multiply(base);            }            return result;        }    }Thread join  스레드는 각각 독립적이고 실행순서를 우리가 통제할 수 없다.  "
  },
  
  {
    "title": "자바 Thread_1",
    "url": "/posts/Java-Thread/",
    "categories": "자바, 멀티스레딩",
    "tags": "java",
    "date": "2023-11-20 23:09:22 +0900",
    





    
    "snippet": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/...",
    "content": "  왜 쓰레드가 필요한가??  반응성  성능  컨텍스트 스위치          어플리케이션 각각의 인스턴스는 독립적으로 실행이 됨.      일반적으로는 코어의 개수보다 프로세스의 개수가 더 많고, 하나의 프로세스는 하나 이상의 쓰레드가 있음.그래서 OS는 스레드 하나를 실행하고, 멈추고 다시 실행하는것이 컨텍스트 스위치&lt;/br&gt; &lt;/br&gt; &lt;/br&gt;                  컨텍스트 스위치                            동시에 많은 스레드를 다룰 때는 효율성이 떨어지기에 이 개념이 아주 중요함 !      사람으로 생각하면 생각을 가다듬고, 집중력을 회복하는 시간 ! (회사에서 많은 업무를 동시에 못하는것처럼!!)      CPU에서 실행되는 각 스레드는 CPU 안에 레지스터, 캐시, 메모리 내의 커널 리소스 일정 부분을 차지하게됨.다른 쓰레드로 전환할 때는 기존의 모든 데이터를 저장하고, 다른 쓰레드의 리소스를 CPU와 메모리에 복원해야함.            너무 많은 스레드를 사용시 ‘스래싱’이 발행    같은 프로세스에 속한 두 스레드 간의 컨텍스트 스위치(효율) » 다른 프로세스의 두 스레드간의 스위치(비효율)      그럼 언제 컨텍스트 스위치를 할 지 결정하는가??    쓰레드 스케줄          들어온 순서대로 작업을 처리할지?      짧은 시간인것부터 먼저 처리할지?        쓰레드 vs 프로세스          멀티 스레드와 멀티 프로세스.      스레드는 많은 리소스를 공유하니 같은 프로세스 안에서 스레드를 사용하는 것이 좋음.      보안,안정성 -&gt; 멀티 스레드는 스레드 하나에 프로세스가 다운될 가능성도 있음.      자바 스레드의 기능과 디버깅 방법        // 스레드 생성        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                System.out.println(\"now thread: \" + Thread.currentThread().getName());                System.out.println(\"current thread: \" + Thread.currentThread().getPriority());                /* 에러 반환 */                throw new RuntimeException(\"Exception\");            }        });        // 스레드에 문제를 생겼을때 해당 헨들러가 작동해서 에러를 반환        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                System.out.println(\"error happy\");            }        });&lt;/br&gt;자바 스레드 상속 예제public static final int MAX_PASSWORD = 9999;    public static void main(String[] args) throws InterruptedException {        Random random = new Random();        Vault vault = new Vault(random.nextInt(MAX_PASSWORD));        // 모든 클래스가 Thread클래스를 상속받았기에 제네릭으로 사용 가능함.        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();        threads.add(new AscendingHackerThread(vault));        threads.add(new DescendingHackerThread(vault));        threads.add(new PoliceThread());        // 쓰레드 담긴 개수만큼 반복해서 실행        for (Thread thread : threads) {            thread.start();        }    }    // 해당 방법처럼 클래스에 쓰레드를 상속받아서 쓰레드클래스로 사용 가능    private static class NewThread extends Thread {        @Override        public void run(){            System.out.println(\"Hello\" + this.getName());        }    }    private static class Vault {        private int passward;        public Vault(int passward) {            this.passward = passward;        }        public boolean isCorrentPassword(int guess) {            try {                Thread.sleep(5);            } catch (Exception e){            }            return this.passward == guess;        }    }    // 쓰레드를 상속받은 클래스를 추상클래스로 만들어 활용    private static abstract class HackerThread extends Thread {        protected Vault vault;        public HackerThread(Vault vault) {            this.vault = vault;            this.setName(this.getClass().getSimpleName());            this.setPriority(Thread.MAX_PRIORITY);        }        @Override        public void start() {            System.out.println(\"string thread: \" + this.getName());            super.start();        }    }    private static class AscendingHackerThread extends HackerThread {        public AscendingHackerThread(Vault vault) {            super(vault);        }        @Override        public void run() {            for (int i = 0; i &lt; MAX_PASSWORD; i++) {                if(vault.isCorrentPassword(i)){                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class DescendingHackerThread extends HackerThread {        public DescendingHackerThread(Vault vault){            super(vault);        }        @Override        public void run() {            for (int i = MAX_PASSWORD; i &gt;= 0; i--) {                if (vault.isCorrentPassword(i)) {                    System.out.println(this.getName() + \"password\" + i);                    System.exit(0);                }            }        }    }    private static class PoliceThread extends Thread {        @Override        public void run() {            for (int i = 10; i &gt; 0; i--) {                try {                    Thread.sleep(1000);                }catch (Exception e) {                }                System.out.println(i);            }            System.out.println(\"Over Hacker\");            System.exit(0);        }    }핵심 !!!!      애플리케이션에서 여러 개의 스레드를 사용하는 이유는 무엇일까요?  =&gt; 여러 개의 스레드를 사용하면 동시에 여러 개의 관련 작업을 실행할 수 있어서, 애플리케이션의 반응성을 향상시킬 수 있기 때문입니다. 또한 여러 개의 작업을 동시에 실행하여 더 뛰어난 성능을 달성할 수도 있습니다.        하나의 프로세스에 속한 스레드가 공유하는 것은?  =&gt; 힙, 코드, 프로세스의 열린 파일, 프로세스의 메타 데이터        OS는 어떤 방식으로 스케줄링할 스레드를 설계하는가?  =&gt; 각 스레드에 대한 동적 우선 순위를 유지해 인터랙티브 스레드를 우선시하고 시스템의 특정 스레드가 기아 상태가 되는 것을 방지하는것이 모든 OS의 목표 (스케줄링 스레드에 대한 알고리즘은 OS마다 다름)  "
  },
  
  {
    "title": "한화시스템 BEYOND 캠프 3기 1주차 회고",
    "url": "/posts/week1/",
    "categories": "한화시스템, 주차회고",
    "tags": "hanhwa",
    "date": "2023-11-19 12:00:00 +0900",
    





    
    "snippet": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장...",
    "content": "한화시스템 BEYOND 캠프 3기 1주차 회고내용1. 전반적인 느낀 점 (일주일 동안 한 일)- 지금까지 7시 출근 - 4시 퇴근을 한 입장해서   9시출근 - 6시퇴근이라는게 가장 좋다.그리고 교육장소까지 가는 시간도 40분이면 갈 수 있어서 위치적으로도 좋아서 마음에 든다.2. 좋았던 점 (좋았거나 내가 잘했던 점)- 강사님이 스타트업 리드, 팀장 경험이 있었다는 점.  국비는 강사의 역량이 절반이상이라도 들었는데, 적어도 인터넷에서 본 이상한 강사님이 아니라서 좋았다.  - 커리큘럼을 봤을때 생각보다 탄탄했다. (CI/CD까지 하는 곳은 잘 못본거같은데, 거기다가 Action!!)  - 생각보다 건물 안이 깨끗했고 원두커피를 아침, 점심, 저녁마다 먹을 수 있었다 !- 매니저님들이 생각 이상으로 신경을 잘 써주시고, 최대한 도와주시려고 함. 3. 아쉬웠던 점- 일단 화장실이 너무 작았다. 갈때마다 기다리는게 쉽지 않다.  - 수업을 듣는 교육실이 생각보다 작았고, 듀얼모니터 지원X (너무 좋은 환경의 이야기만 들은것일 순 있음)- 커리큘럼의 내용이 탄탄한만큼 시간안에 끝낼 수 있는지 강사님이 먼저 걱정된다;;;  - 내용을 제로베이스에서 시작 + 짧은시간 + 많은 내용을 하다보니 토익700점반처럼 내용을 공식처럼 외우는 느낌이였음. 4. 개선할 점- 앞으로는 강사님 수업내용을 블로그에 바로 정리해서 올릴 수 있도록 하기 !5. 다음주 계획- 블로그를 빠르게 적기위해, 마크다운을 익숙해지도록 하기- 자바 공부 및 정리."
  },
  
  {
    "title": "첫 블로그 글, 소개",
    "url": "/posts/intro/",
    "categories": "일상, 소개",
    "tags": "introduce",
    "date": "2023-11-17 23:09:22 +0900",
    





    
    "snippet": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 ...",
    "content": "블로그 첫 글Email - junstin119@gmail.comGitHub - https://github.com/J-unStiN소개 - https://junstin.notion.site/68e463fee882498cb424226dff3447ed?pvs=4  블로그, Github 위해 마크다운에 대한 글 작성하기      자바를 처음사용하는만큼 자바에 대해 필요한 부분들 정리    추후 꾸준하게 해당글을 수정하도록 약속함."
  }
  
]

